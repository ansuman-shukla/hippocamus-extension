Directory structure:
└── ansuman-shukla-hippocamus-extension/
    ├── backend/
    │   ├── requirements.txt
    │   └── app/
    │       ├── main.py
    │       ├── core/
    │       │   ├── config.py
    │       │   ├── database.py
    │       │   ├── database_wrapper.py
    │       │   ├── pinecone_wrapper.py
    │       │   ├── pineConeDB.py
    │       │   └── rate_limiter.py
    │       ├── exceptions/
    │       │   ├── databaseExceptions.py
    │       │   ├── deleteExceptions.py
    │       │   ├── global_exceptions.py
    │       │   ├── httpExceptionsSave.py
    │       │   └── httpExceptionsSearch.py
    │       ├── models/
    │       │   ├── bookmarkModels.py
    │       │   ├── notesModel.py
    │       │   └── user_model.py
    │       ├── routers/
    │       │   ├── auth_router.py
    │       │   ├── bookmarkRouters.py
    │       │   ├── get_quotes.py
    │       │   ├── notesRouter.py
    │       │   └── summaryRouter.py
    │       ├── schema/
    │       │   ├── bookmarksSchema.py
    │       │   ├── link_schema.py
    │       │   ├── notesSchema.py
    │       │   └── users_schema.py
    │       ├── services/
    │       │   ├── memories_service.py
    │       │   ├── notes_service.py
    │       │   ├── pinecone_service.py
    │       │   ├── quotesService.py
    │       │   ├── summariseService.py
    │       │   └── user_service.py
    │       └── utils/
    │           ├── jwt.py
    │           ├── quotes_dict.py
    │           ├── site_name_extractor.py
    │           └── space_extractor.py
    └── frontend/
        ├── README.md
        ├── eslint.config.js
        ├── index.html
        ├── package.json
        ├── postcss.config.js
        ├── tailwind.config.js
        ├── trial.txt
        ├── tsconfig.app.json
        ├── tsconfig.json
        ├── tsconfig.node.json
        ├── vite.config.ts
        ├── public/
        │   ├── auth-content-script.js
        │   ├── background.js
        │   ├── content.css
        │   ├── content.js
        │   ├── error.html
        │   ├── index.html
        │   └── manifest.json
        ├── scripts/
        │   └── replace-env-vars.mjs
        └── src/
            ├── App.css
            ├── App.tsx
            ├── index.css
            ├── main.tsx
            ├── supabaseClient.ts
            ├── vite-env.d.ts
            ├── assets/
            │   ├── Google Sans Mono-normal-400-100.ttf
            │   ├── Google Sans Mono-normal-500-100.ttf
            │   ├── Google Sans Mono-normal-700-100.ttf
            │   ├── Google Sans Text-normal-400-100.ttf
            │   └── Google Sans Text-normal-700-100.ttf
            ├── components/
            │   ├── AuthComponent.tsx
            │   ├── AuthLoadingIndicator.tsx
            │   ├── Button.tsx
            │   ├── Cards.tsx
            │   ├── ClickSpark.tsx
            │   ├── InputForm.tsx
            │   ├── Loader.tsx
            │   ├── LoaderPillars.tsx
            │   ├── ProtectedRoute.tsx
            │   ├── SimpleAuth.tsx
            │   └── toggleTab.tsx
            ├── config/
            │   └── environment.ts
            ├── page/
            │   ├── IntroPage.tsx
            │   ├── ResponsePage.tsx
            │   ├── SearchPage.tsx
            │   ├── SearchResultPage.tsx
            │   └── SummarizePage.tsx
            └── utils/
                ├── api.ts
                ├── apiClient.ts
                └── spaceUtils.ts


Files Content:

================================================
FILE: backend/requirements.txt
================================================
fastapi
uvicorn[standard]
python-jose[cryptography]
motor
requests
python-dotenv
supabase
pinecone
python-dotenv
langchain_community
langchain
langchain_google_genai
pinecone_text
google-generativeai
slowapi


================================================
FILE: backend/app/main.py
================================================
from jose import jwt, JWTError
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
from app.core.config import settings
from app.routers.bookmarkRouters import router as bookmark_router
from app.utils.jwt import decodeJWT, TokenExpiredError
from fastapi.middleware.cors import CORSMiddleware
from app.routers.get_quotes import router as get_quotes_router
from app.routers.notesRouter import router as notes_router
from app.routers.summaryRouter import router as summary_router
from app.routers.auth_router import router as auth_router
from app.exceptions.global_exceptions import (
    global_exception_handler,
    AuthenticationError,
    create_error_response
)
from app.core.database_wrapper import get_database_health
from app.core.pinecone_wrapper import get_pinecone_health
from slowapi import _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded
from slowapi.middleware import SlowAPIMiddleware

load_dotenv()

import logging
from datetime import datetime

# Configure basic logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# Helper functions for authentication middleware
def validate_user_id(payload, context="token"):
    user_id = payload.get("sub")
    if not user_id:
        logger.warning(f"Missing user ID in {context}")
        return None, create_error_response("Invalid payload", 401, "auth_error")
    return user_id, None

def create_auth_error_response(message, status_code=401):
    """Create a standardized authentication error response"""
    return create_error_response(
        message,
        status_code=status_code,
        error_type="auth_error"
    )


# Import the limiter from the dedicated module to avoid circular imports
from app.core.rate_limiter import limiter

# Create FastAPI app with enhanced error handling and disabled documentation
app = FastAPI(
    title="HippoCampus API",
    description="I help you remember everything",
    version="1.0.0",
    docs_url=None,     # Disable Swagger UI
    redoc_url=None,    # Disable ReDoc
    openapi_url=None   # Disable OpenAPI JSON endpoint
)

# Add rate limiter to app state and configure middleware
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
app.add_middleware(SlowAPIMiddleware)

@app.middleware("http")
async def authorisation_middleware(request: Request, call_next):
    """
    Simplified authentication middleware using direct JWT handling
    """
    logger.info(f"Incoming request: {request.method} {request.url.path}")

    # Skip auth for some public endpoints
    if request.url.path in ["/health", "/health/detailed"] or request.url.path.startswith("/quotes"):
        return await call_next(request)

    try:
        # Check both cookies and Authorization header
        auth_header = request.headers.get("authorization")
        
        logger.info(f"🔍 AUTH CHECK: Request details:")
        logger.info(f"   ├─ Authorization header: {auth_header[:50] + '...' if auth_header else 'None'}")
        
        # If no cookie, try to extract from Authorization header
        if auth_header:
            if auth_header.lower().startswith("bearer "):
                access_token = auth_header[7:].strip()
                logger.info(f"   └─ Extracted token from Authorization header")
        
        if not access_token:
            logger.warning("❌ AUTH: Access token missing from Authorization header")
            return create_auth_error_response("Access token is missing")

        # Decode the JWT token directly
        payload = jwt.decode(
            token=access_token,
            key=settings.SUPABASE_JWT_SECRET,
            algorithms=["HS256"],
            options={"verify_aud": True},
            audience="authenticated"
        )

        # Validate sub claim
        user_id = payload.get("sub")
        if not user_id:
            logger.warning("JWT missing subject (user ID)")
            return create_auth_error_response("Invalid JWT payload")

        logger.info(f"Access token valid for user: {user_id}")

        # Set user_id in the request state
        request.state.user_id = user_id

        # Continue the request
        response = await call_next(request)
        return response

    except JWTError as e:
        logger.error(f"JWT validation failed: {str(e)}")
        return create_auth_error_response("Invalid token")

    except HTTPException as e:
        logger.error(f"HTTP exception during token validation: {e.detail}")
        return create_error_response(e.detail, status_code=e.status_code, error_type="auth_error")

    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}", exc_info=True)
        return create_error_response("Authentication service temporarily unavailable", status_code=503, error_type="auth_service_error")


# Add global exception handler
app.add_exception_handler(Exception, global_exception_handler)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check endpoints
@app.get("/health")
async def health_check():
    """Basic health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "service": "HippoCampus API"
    }

@app.get("/health/detailed")
async def detailed_health_check():
    """Detailed health check including database and external services"""
    try:
        db_health = await get_database_health()
        pinecone_health = await get_pinecone_health()

        overall_status = "healthy"
        if (db_health.get("status") != "healthy" or
            pinecone_health.get("status") != "healthy"):
            overall_status = "degraded"

        return {
            "status": overall_status,
            "timestamp": datetime.now().isoformat(),
            "services": {
                "database": db_health,
                "vector_db": pinecone_health
            }
        }
    except Exception as e:
        logger.error(f"Error in detailed health check: {str(e)}")
        return JSONResponse(
            status_code=503,
            content={
                "status": "unhealthy",
                "timestamp": datetime.now().isoformat(),
                "error": "Health check failed"
            }
        )

app.include_router(bookmark_router)
app.include_router(get_quotes_router)
app.include_router(notes_router)
app.include_router(summary_router)
app.include_router(auth_router)



================================================
FILE: backend/app/core/config.py
================================================
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    SUPABASE_URL: str
    SUPABASE_API_KEY: str
    SUPABASE_ANON_KEY: str
    SUPABASE_SERVICE_ROLE_KEY: str
    SUPABASE_JWT_SECRET: str  # This is the JWT secret from Supabase dashboard
    MONGODB_DB: str
    MONGODB_URI: str
    PINECONE_API_KEY: str
    PINECONE_INDEX: str
    GEMINI_API_KEY: str
    MONGODB_COLLECTION_USER: str
    MONGODB_COLLECTION_NOTES: str
    MONGODB_COLLECTION_MEMORIES: str


    class Config:
        env_file = ".env"

settings = Settings()


================================================
FILE: backend/app/core/database.py
================================================
from app.core.config import settings
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi


uri = settings.MONGODB_URI

# Create a new client and connect to the server
client = MongoClient(uri, server_api=ServerApi('1'))

db = client[settings.MONGODB_DB]

# Create a new collection
collection = db[settings.MONGODB_COLLECTION_USER]
collection_memories = db[settings.MONGODB_COLLECTION_MEMORIES]
collection_notes = db[settings.MONGODB_COLLECTION_NOTES]






================================================
FILE: backend/app/core/database_wrapper.py
================================================
import logging
import time
from typing import Optional, Any, Dict
from functools import wraps
from pymongo.errors import PyMongoError, ConnectionFailure, ServerSelectionTimeoutError
from app.exceptions.global_exceptions import DatabaseConnectionError
from app.core.database import client, db, collection, collection_memories, collection_notes

logger = logging.getLogger(__name__)

class DatabaseWrapper:
    """
    Database wrapper with connection retry logic and graceful error handling
    """
    
    def __init__(self, max_retries: int = 3, retry_delay: float = 1.0):
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self._connection_healthy = True
        
    def check_connection(self) -> bool:
        """Check if database connection is healthy"""
        try:
            # Simple ping to check connection
            client.admin.command('ping')
            self._connection_healthy = True
            return True
        except Exception as e:
            logger.warning(f"Database connection check failed: {str(e)}")
            self._connection_healthy = False
            return False
    
    def retry_on_connection_error(self, func):
        """Decorator to retry database operations on connection errors"""
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(self.max_retries + 1):
                try:
                    # Check connection before attempting operation
                    if not self.check_connection():
                        raise DatabaseConnectionError("Database connection is not healthy")
                    
                    return await func(*args, **kwargs)
                    
                except (ConnectionFailure, ServerSelectionTimeoutError) as e:
                    last_exception = e
                    logger.warning(
                        f"Database connection error on attempt {attempt + 1}/{self.max_retries + 1}: {str(e)}"
                    )
                    
                    if attempt < self.max_retries:
                        wait_time = self.retry_delay * (2 ** attempt)  # Exponential backoff
                        logger.info(f"Retrying in {wait_time} seconds...")
                        time.sleep(wait_time)
                    else:
                        logger.error(f"All database retry attempts failed: {str(e)}")
                        raise DatabaseConnectionError(
                            "Database service is temporarily unavailable",
                            details={"attempts": self.max_retries + 1, "error": str(e)}
                        )
                        
                except PyMongoError as e:
                    logger.error(f"Database operation error: {str(e)}")
                    raise DatabaseConnectionError(
                        "Database operation failed",
                        details={"error": str(e), "operation": func.__name__}
                    )
                    
                except Exception as e:
                    logger.error(f"Unexpected error in database operation: {str(e)}")
                    raise
            
            # This should never be reached, but just in case
            if last_exception:
                raise DatabaseConnectionError(
                    "Database operation failed after all retries",
                    details={"error": str(last_exception)}
                )
                
        return wrapper
    
    @property
    def is_healthy(self) -> bool:
        """Check if the database connection is currently healthy"""
        return self._connection_healthy

# Create global database wrapper instance
db_wrapper = DatabaseWrapper()

class SafeCollection:
    """
    Safe collection wrapper that handles database errors gracefully
    """
    
    def __init__(self, collection, wrapper: DatabaseWrapper):
        self._collection = collection
        self._wrapper = wrapper
    
    @property
    def wrapper(self):
        return self._wrapper
    
    async def insert_one(self, document: Dict[str, Any], **kwargs):
        """Safely insert a document"""
        @self._wrapper.retry_on_connection_error
        async def _insert():
            return self._collection.insert_one(document, **kwargs)
        return await _insert()
    
    async def find_one(self, filter_dict: Dict[str, Any] = None, **kwargs):
        """Safely find one document"""
        @self._wrapper.retry_on_connection_error
        async def _find_one():
            return self._collection.find_one(filter_dict or {}, **kwargs)
        return await _find_one()
    
    async def find(self, filter_dict: Dict[str, Any] = None, **kwargs):
        """Safely find documents"""
        @self._wrapper.retry_on_connection_error
        async def _find():
            return list(self._collection.find(filter_dict or {}, **kwargs))
        return await _find()
    
    async def update_one(self, filter_dict: Dict[str, Any], update: Dict[str, Any], **kwargs):
        """Safely update one document"""
        @self._wrapper.retry_on_connection_error
        async def _update():
            return self._collection.update_one(filter_dict, update, **kwargs)
        return await _update()
    
    async def delete_one(self, filter_dict: Dict[str, Any], **kwargs):
        """Safely delete one document"""
        @self._wrapper.retry_on_connection_error
        async def _delete():
            return self._collection.delete_one(filter_dict, **kwargs)
        return await _delete()
    
    async def count_documents(self, filter_dict: Dict[str, Any] = None, **kwargs):
        """Safely count documents"""
        @self._wrapper.retry_on_connection_error
        async def _count():
            return self._collection.count_documents(filter_dict or {}, **kwargs)
        return await _count()

# Create safe collection wrappers
safe_collection = SafeCollection(collection, db_wrapper)
safe_collection_memories = SafeCollection(collection_memories, db_wrapper)
safe_collection_notes = SafeCollection(collection_notes, db_wrapper)

async def get_database_health() -> Dict[str, Any]:
    """Get database health status"""
    try:
        is_healthy = db_wrapper.check_connection()
        return {
            "status": "healthy" if is_healthy else "unhealthy",
            "connection_healthy": is_healthy,
            "timestamp": time.time()
        }
    except Exception as e:
        logger.error(f"Error checking database health: {str(e)}")
        return {
            "status": "error",
            "connection_healthy": False,
            "error": str(e),
            "timestamp": time.time()
        }



================================================
FILE: backend/app/core/pinecone_wrapper.py
================================================
import logging
import time
from typing import Optional, Any, Dict, List
from functools import wraps
from pinecone.exceptions import PineconeException
from app.exceptions.global_exceptions import ExternalServiceError
from app.core.pineConeDB import pc, index

logger = logging.getLogger(__name__)

class PineconeWrapper:
    """
    Pinecone wrapper with retry logic and graceful error handling
    """
    
    def __init__(self, max_retries: int = 3, retry_delay: float = 1.0):
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self._connection_healthy = True
        
    def check_connection(self) -> bool:
        """Check if Pinecone connection is healthy"""
        try:
            # Try to get index stats as a health check
            stats = index.describe_index_stats()
            self._connection_healthy = True
            return True
        except Exception as e:
            logger.warning(f"Pinecone connection check failed: {str(e)}")
            self._connection_healthy = False
            return False
    
    def retry_on_connection_error(self, func):
        """Decorator to retry Pinecone operations on connection errors"""
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(self.max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                    
                except PineconeException as e:
                    last_exception = e
                    logger.warning(
                        f"Pinecone error on attempt {attempt + 1}/{self.max_retries + 1}: {str(e)}"
                    )
                    
                    if attempt < self.max_retries:
                        wait_time = self.retry_delay * (2 ** attempt)  # Exponential backoff
                        logger.info(f"Retrying Pinecone operation in {wait_time} seconds...")
                        time.sleep(wait_time)
                    else:
                        logger.error(f"All Pinecone retry attempts failed: {str(e)}")
                        raise ExternalServiceError(
                            "Vector database service is temporarily unavailable",
                            details={"attempts": self.max_retries + 1, "error": str(e)}
                        )
                        
                except Exception as e:
                    logger.error(f"Unexpected error in Pinecone operation: {str(e)}")
                    # Don't retry on unexpected errors
                    raise ExternalServiceError(
                        "Vector database operation failed",
                        details={"error": str(e), "operation": func.__name__}
                    )
            
            # This should never be reached, but just in case
            if last_exception:
                raise ExternalServiceError(
                    "Vector database operation failed after all retries",
                    details={"error": str(last_exception)}
                )
                
        return wrapper
    
    @property
    def is_healthy(self) -> bool:
        """Check if the Pinecone connection is currently healthy"""
        return self._connection_healthy

# Create global Pinecone wrapper instance
pinecone_wrapper = PineconeWrapper()

class SafePineconeIndex:
    """
    Safe Pinecone index wrapper that handles errors gracefully
    """
    
    def __init__(self, index, wrapper: PineconeWrapper):
        self._index = index
        self._wrapper = wrapper
    
    @property
    def wrapper(self):
        return self._wrapper
    
    async def upsert(self, vectors: List[Dict], namespace: str = None, **kwargs):
        """Safely upsert vectors"""
        @self._wrapper.retry_on_connection_error
        async def _upsert():
            return self._index.upsert(vectors=vectors, namespace=namespace, **kwargs)
        return await _upsert()
    
    async def query(self, vector: List[float] = None, namespace: str = None, 
                   top_k: int = 10, include_metadata: bool = True, 
                   filter: Dict = None, **kwargs):
        """Safely query vectors"""
        @self._wrapper.retry_on_connection_error
        async def _query():
            return self._index.query(
                vector=vector,
                namespace=namespace,
                top_k=top_k,
                include_metadata=include_metadata,
                filter=filter,
                **kwargs
            )
        return await _query()
    
    async def delete(self, ids: List[str] = None, namespace: str = None, 
                    filter: Dict = None, **kwargs):
        """Safely delete vectors"""
        @self._wrapper.retry_on_connection_error
        async def _delete():
            return self._index.delete(ids=ids, namespace=namespace, filter=filter, **kwargs)
        return await _delete()
    
    async def describe_index_stats(self, **kwargs):
        """Safely get index statistics"""
        @self._wrapper.retry_on_connection_error
        async def _stats():
            return self._index.describe_index_stats(**kwargs)
        return await _stats()

class SafePineconeClient:
    """
    Safe Pinecone client wrapper for embedding operations
    """
    
    def __init__(self, client, wrapper: PineconeWrapper):
        self._client = client
        self._wrapper = wrapper
    
    async def embed(self, model: str, inputs: List[str], parameters: Dict = None, **kwargs):
        """Safely generate embeddings"""
        @self._wrapper.retry_on_connection_error
        async def _embed():
            return self._client.inference.embed(
                model=model,
                inputs=inputs,
                parameters=parameters or {},
                **kwargs
            )
        return await _embed()

# Create safe wrappers
safe_index = SafePineconeIndex(index, pinecone_wrapper)
safe_pc = SafePineconeClient(pc, pinecone_wrapper)

async def get_pinecone_health() -> Dict[str, Any]:
    """Get Pinecone health status"""
    try:
        is_healthy = pinecone_wrapper.check_connection()
        if is_healthy:
            stats = await safe_index.describe_index_stats()
            return {
                "status": "healthy",
                "connection_healthy": True,
                "index_stats": stats,
                "timestamp": time.time()
            }
        else:
            return {
                "status": "unhealthy",
                "connection_healthy": False,
                "timestamp": time.time()
            }
    except Exception as e:
        logger.error(f"Error checking Pinecone health: {str(e)}")
        return {
            "status": "error",
            "connection_healthy": False,
            "error": str(e),
            "timestamp": time.time()
        }



================================================
FILE: backend/app/core/pineConeDB.py
================================================
from pinecone import Pinecone
from app.core.config import settings
from langchain_community.retrievers import PineconeHybridSearchRetriever
from pinecone_text.sparse import BM25Encoder
import nltk
from pinecone import Pinecone, ServerlessSpec
from langchain_google_genai import GoogleGenerativeAIEmbeddings
import os

index_name = settings.PINECONE_INDEX
GEMINI_API_KEY = settings.GEMINI_API_KEY
pc = Pinecone(api_key=settings.PINECONE_API_KEY)


# BM25_ENCODER_FILE = r"bm25_encoder.pkl"

# def get_bm25_encoder():
#     """Load or initialize BM25 encoder with persistent storage"""
#     if os.path.exists(BM25_ENCODER_FILE) and os.path.getsize(BM25_ENCODER_FILE) > 0:
#         try:
#             # Create new instance first okay ??

#             encoder = BM25Encoder()
#             # Then load into the instance
#             encoder.load(BM25_ENCODER_FILE)
#             return encoder
#         except Exception as e:
#             print(f"Error loading encoder: {e}, creating new one")
#             os.remove(BM25_ENCODER_FILE)
    
#     # Initialize new encoder and save properly
#     encoder = BM25Encoder.default()
#     os.makedirs(os.path.dirname(BM25_ENCODER_FILE), exist_ok=True)
#     encoder.dump(BM25_ENCODER_FILE)
#     return encoder

# bm25encoder = get_bm25_encoder()



# Initialize Pinecone index
if index_name not in pc.list_indexes().names():
    pc.create_index(
        name=index_name,
        dimension=1024,  # E5-large requires 1024 dimensions
        metric="cosine",  # E5 works best with cosine similarity
        spec=ServerlessSpec(cloud='aws', region='us-east-1')
    )

index = pc.Index(index_name)


================================================
FILE: backend/app/core/rate_limiter.py
================================================
from fastapi import Request
from slowapi import Limiter
from slowapi.util import get_remote_address

def get_user_route_key(request: Request) -> str:
    """
    Generate a unique key for rate limiting based on user_id and route.
    Falls back to IP address for unauthenticated requests.
    """
    # Get user_id from request state (set by auth middleware)
    user_id = getattr(request.state, 'user_id', None)
    route_path = request.url.path
    
    if user_id:
        # For authenticated users: use user_id + route for rate limiting
        return f"user:{user_id}:route:{route_path}"
    else:
        # For unauthenticated requests: use IP + route
        client_ip = get_remote_address(request)
        return f"ip:{client_ip}:route:{route_path}"

# Initialize rate limiter with in-memory storage (no Redis)
limiter = Limiter(key_func=get_user_route_key) 


================================================
FILE: backend/app/exceptions/databaseExceptions.py
================================================
import logging

logger = logging.getLogger(__name__)

class MemoryServiceError(Exception):
    """Base exception for memory service errors"""
    pass

class MemoryValidationError(MemoryServiceError):
    """Raised when memory data is invalid"""
    pass

class MemoryDatabaseError(MemoryServiceError):
    """Raised when database operations fail"""
    pass

class MemoryNotFoundError(MemoryServiceError):
    """Raised when a requested memory document cannot be found"""
    pass


================================================
FILE: backend/app/exceptions/deleteExceptions.py
================================================
import logging
from typing import Optional
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class DocumentSaveError(Exception):
    def __init__(self, message: str, user_id: Optional[str] = None, doc_id: Optional[str] = None):
        super().__init__(message)
        self.user_id = user_id
        self.doc_id = doc_id    

        


================================================
FILE: backend/app/exceptions/global_exceptions.py
================================================
import logging
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from pymongo.errors import PyMongoError, ConnectionFailure, ServerSelectionTimeoutError
from pinecone.exceptions import PineconeException
from jose import JWTError
from pydantic import ValidationError
import traceback
from typing import Union
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ApplicationError(Exception):
    """Base application exception"""
    def __init__(self, message: str, status_code: int = 500, details: dict = None):
        super().__init__(message)
        self.message = message
        self.status_code = status_code
        self.details = details or {}
        self.timestamp = datetime.now().isoformat()

class DatabaseConnectionError(ApplicationError):
    """Database connection related errors"""
    def __init__(self, message: str = "Database connection failed", details: dict = None):
        super().__init__(message, status_code=503, details=details)

class ExternalServiceError(ApplicationError):
    """External service related errors"""
    def __init__(self, message: str = "External service unavailable", details: dict = None):
        super().__init__(message, status_code=503, details=details)

class AuthenticationError(ApplicationError):
    """Authentication related errors"""
    def __init__(self, message: str = "Authentication failed", details: dict = None):
        super().__init__(message, status_code=401, details=details)

class ValidationError(ApplicationError):
    """Validation related errors"""
    def __init__(self, message: str = "Validation failed", details: dict = None):
        super().__init__(message, status_code=422, details=details)

async def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """
    Global exception handler that catches all unhandled exceptions
    and returns appropriate JSON responses instead of crashing the app.
    """
    
    # Log the exception with full traceback
    logger.error(
        f"Unhandled exception in {request.method} {request.url}: {str(exc)}",
        exc_info=True,
        extra={
            "method": request.method,
            "url": str(request.url),
            "client": request.client.host if request.client else "unknown",
            "user_agent": request.headers.get("user-agent", "unknown")
        }
    )
    
    # Handle specific exception types
    if isinstance(exc, ApplicationError):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "error": exc.message,
                "details": exc.details,
                "timestamp": exc.timestamp,
                "type": "application_error"
            }
        )
    
    elif isinstance(exc, HTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "error": exc.detail,
                "timestamp": datetime.now().isoformat(),
                "type": "http_error"
            }
        )
    
    elif isinstance(exc, StarletteHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "error": exc.detail,
                "timestamp": datetime.now().isoformat(),
                "type": "http_error"
            }
        )
    
    elif isinstance(exc, RequestValidationError):
        return JSONResponse(
            status_code=422,
            content={
                "error": "Validation error",
                "details": exc.errors(),
                "timestamp": datetime.now().isoformat(),
                "type": "validation_error"
            }
        )
    
    elif isinstance(exc, (ConnectionFailure, ServerSelectionTimeoutError, PyMongoError)):
        return JSONResponse(
            status_code=503,
            content={
                "error": "Database service temporarily unavailable",
                "message": "Please try again later",
                "timestamp": datetime.now().isoformat(),
                "type": "database_error"
            }
        )
    
    elif isinstance(exc, PineconeException):
        return JSONResponse(
            status_code=503,
            content={
                "error": "Vector database service temporarily unavailable",
                "message": "Please try again later",
                "timestamp": datetime.now().isoformat(),
                "type": "vector_db_error"
            }
        )
    
    elif isinstance(exc, JWTError):
        return JSONResponse(
            status_code=401,
            content={
                "error": "Authentication failed",
                "message": "Invalid or expired token",
                "timestamp": datetime.now().isoformat(),
                "type": "auth_error"
            }
        )
    
    # Handle any other unexpected exceptions
    else:
        # Log critical error for investigation
        logger.critical(
            f"Unexpected exception: {type(exc).__name__}: {str(exc)}",
            exc_info=True,
            extra={
                "exception_type": type(exc).__name__,
                "traceback": traceback.format_exc()
            }
        )
        
        return JSONResponse(
            status_code=500,
            content={
                "error": "Internal server error",
                "message": "An unexpected error occurred. Please try again later.",
                "timestamp": datetime.now().isoformat(),
                "type": "internal_error"
            }
        )

def create_error_response(
    message: str, 
    status_code: int = 500, 
    details: dict = None,
    error_type: str = "error"
) -> JSONResponse:
    """Helper function to create consistent error responses"""
    return JSONResponse(
        status_code=status_code,
        content={
            "error": message,
            "details": details or {},
            "timestamp": datetime.now().isoformat(),
            "type": error_type
        }
    )



================================================
FILE: backend/app/exceptions/httpExceptionsSave.py
================================================
import logging
from fastapi import HTTPException
from typing import Optional
from datetime import datetime
from pydantic import ValidationError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class DocumentSaveError(Exception):
    """Base exception for document saving failures"""
    def __init__(self, message: str, user_id: Optional[str] = None, doc_id: Optional[str] = None):
        super().__init__(message)
        self.user_id = user_id
        self.doc_id = doc_id

class InvalidURLError(DocumentSaveError):
    """Raised when a URL is malformed or unsupported"""
    pass

class VectorDBConnectionError(DocumentSaveError):
    """Raised when connection to vector database fails"""
    pass

class DocumentStorageError(DocumentSaveError):
    """Raised when document storage operation fails"""
    pass


class DatabaseError(DocumentSaveError):
    """Raised when a database operation fails"""
    pass


================================================
FILE: backend/app/exceptions/httpExceptionsSearch.py
================================================
from fastapi import HTTPException

# Custom exceptions for business logic
class InvalidRequestError(Exception):
    """Raised when invalid parameters are provided"""
    pass

class VectorDBConnectionError(Exception):
    """Raised when connection to vector database fails"""
    pass

class MissingNamespaceError(Exception):
    """Raised when user namespace is not found"""
    pass

class SearchExecutionError(Exception):
    """Raised when search operation fails"""
    pass



================================================
FILE: backend/app/models/bookmarkModels.py
================================================
def bookmarkModel(item):
    return {
        'id': str(item.get('_id', '')) if item.get('_id') else None,
        'doc_id': item.get('doc_id', None),
        'user_id': item.get('user_id', None),
        'title': item.get('title', None),
        'type': item.get('type', None),
        'note': item.get('note', None),
        'source_url': item.get('source_url', None),
        'site_name': item.get('site_name', None),
        'date': item.get('date', None),
        'space': item.get('space', None)
    }

def bookmarkModels(items):
    return [bookmarkModel(item) for item in items]


================================================
FILE: backend/app/models/notesModel.py
================================================
def note_model(item):
    return {
        'id': str(item.get('_id', '')) if item.get('_id') else None,
        'doc_id': item.get('doc_id', None),
        'user_id': item.get('user_id', None),
        'type' : item.get('type', None),
        'title': item.get('title', None),
        'note': item.get('note', None),
        'date': item.get('date', None),
        'space': item.get('space', None)
    }


def note_models(items):
    return [note_model(item) for item in items]


================================================
FILE: backend/app/models/user_model.py
================================================
def userModel(item):
    return {
        'id': str(item['_id']),
        'email': item['email'],
        'role': item['role'],
        'created_at': item['created_at'],
        'last_sign_in_at': item['last_sign_in_at'],
        'full_name': item['full_name'],
        'picture': item['picture'],
        'issuer': item['issuer'],
        'provider': item['provider'],
        'providers': item['providers']    
    }

def userModels(items):
    return [userModel(item) for item in items]


================================================
FILE: backend/app/routers/auth_router.py
================================================
from fastapi import APIRouter, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from app.utils.jwt import decodeJWT
import logging
import time

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth", tags=["authentication"])


class LoginRequest(BaseModel):
    access_token: str
    refresh_token: str

@router.get("/status")
async def auth_status(request: Request):
    """
    Check authentication status and validate current token
    """

    # Check both cookies and Authorization header for tokens
    access_token = request.cookies.get("access_token")
    refresh_token = request.cookies.get("refresh_token")
    
    # If no access token in cookies, check Authorization header
    if not access_token:
        auth_header = request.headers.get("authorization")
        if auth_header and auth_header.lower().startswith("bearer "):
            access_token = auth_header[7:].strip()
            logger.info(f"   ├─ Access token extracted from Authorization header")
    
    logger.info(f"   ├─ Access token present: {bool(access_token)}")
    logger.info(f"   ├─ Refresh token present: {bool(refresh_token)}")

    result = {
        "has_access_token": bool(access_token),
        "has_refresh_token": bool(refresh_token),
        "is_authenticated": False,
        "user_id": None,
        "token_valid": False
    }
    
    if access_token:
        try:
            payload = await decodeJWT(access_token)
            user_metadata = payload.get("user_metadata", {})

            result.update({
                "is_authenticated": True,
                "user_id": payload.get("sub"),
                "token_valid": True,
                "user_email": payload.get("email"),
                "user_name": user_metadata.get("full_name"),
                "full_name": user_metadata.get("full_name"),
                "user_picture": user_metadata.get("picture"),
                "picture": user_metadata.get("picture"),
                "token_expires": payload.get("exp")
            })
        except Exception as e:  
                logger.error(f"❌ AUTH STATUS: Access token validation failed: {str(e)}")
                result["token_error"] = str(e)
    else:
        logger.info(f"ℹ️  AUTH STATUS: No access token to validate")
    
    return result



================================================
FILE: backend/app/routers/bookmarkRouters.py
================================================
# links.py - API endpoints
from fastapi import APIRouter , HTTPException , Request 
from app.exceptions.httpExceptionsSearch import *
from app.exceptions.httpExceptionsSave import *
from app.schema.link_schema import Link as link_schema
from typing import List, Optional, Dict
from langchain_core.documents import Document
from app.services.pinecone_service import *
from app.services.memories_service import *
from app.core.rate_limiter import limiter
from pydantic import BaseModel

# https://hippocampus-backend.onrender.com/links/save for saving links
# https://hippocampus-backend.onrender.com/links/search for searching links

router = APIRouter(
    prefix="/links",
    tags=["Links"]
)

class SearchRequest(BaseModel):
    query: str
    filter: Optional[Dict] = None

@router.post("/save")
@limiter.limit("10/minute")
async def save_link(
    link_data: link_schema,
    request: Request
):
    """Endpoint for saving links to vector database"""
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized save attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")
    
    try:
        logger.info(f"Attempting to save document for user {user_id}")
        result = await save_to_vector_db(obj=link_data, namespace=user_id)
        logger.info(f"Successfully saved document for user {user_id}")
        return result
    except DocumentSaveError as e:
        logger.error(f"Document save failed for user {e.user_id}: {str(e)}", exc_info=True)
        status_code = 400 if isinstance(e, InvalidURLError) else 503
        raise HTTPException(status_code=status_code, detail=str(e))
    except ValidationError as e:
        logger.error(f"Invalid document data for user {user_id}: {str(e)}")
        raise HTTPException(status_code=422, detail="Invalid document format")
    except Exception as e:
        logger.critical(f"Unexpected error saving document for user {user_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("/search")
@limiter.limit("15/minute")
async def search_links(
    search_request: SearchRequest,
    request: Request,
):
    """API endpoint for document search"""
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized search attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")

    try:
        logger.info(f"Attempting to search document for user {user_id}")
        result = await search_vector_db(query=search_request.query, namespace=user_id, filter=search_request.filter)
        logger.info(f"Successfully searched document for user {user_id}")
        return result
    except InvalidRequestError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except (MissingNamespaceError, SearchExecutionError) as e:
        raise HTTPException(status_code=404, detail=str(e))
    except VectorDBConnectionError as e:
        raise HTTPException(status_code=503, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="Internal server error")

@router.delete("/delete")
@limiter.limit("15/minute")
async def delete_link(
    doc_id_pincone: str,
    request: Request
):
    """Delete a link/bookmark with comprehensive logging for debugging"""
    # Log the initial request details
    logger.info(f"=== DELETE REQUEST STARTED ===")
    logger.info(f"Received delete request for doc_id_pincone: '{doc_id_pincone}'")
    logger.info(f"Request URL: {request.url}")
    logger.info(f"Request method: {request.method}")
    logger.info(f"Query params: {dict(request.query_params)}")
    
    # Validate doc_id_pincone parameter
    if not doc_id_pincone or doc_id_pincone.strip() == "":
        logger.error(f"Empty doc_id_pincone received: '{doc_id_pincone}'")
        raise HTTPException(status_code=400, detail="Document ID is required and cannot be empty")
    
    if doc_id_pincone == "undefined" or doc_id_pincone == "null":
        logger.error(f"Invalid doc_id_pincone received: '{doc_id_pincone}' - Frontend is sending undefined/null value")
        raise HTTPException(status_code=400, detail="Invalid document ID: Frontend sent undefined/null value")
    
    logger.info(f"doc_id_pincone validation passed: '{doc_id_pincone}'")
    
    # Validate user authentication
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized delete attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")
    
    logger.info(f"User authentication passed - user_id: '{user_id}'")
    
    try:
        logger.info(f"=== STARTING DELETE OPERATIONS ===")
        logger.info(f"Attempting to delete document '{doc_id_pincone}' for user '{user_id}'")
        
        # Step 1: Delete from vector database
        logger.info(f"STEP 1: Deleting from vector database...")
        vector_result = await delete_from_vector_db(doc_id=doc_id_pincone, namespace=user_id)
        logger.info(f"STEP 1 SUCCESS: Vector database deletion completed: {vector_result}")
        
        # Step 2: Delete from regular database
        logger.info(f"STEP 2: Deleting from regular database...")
        db_result = await delete_from_db(doc_id_pincone)
        logger.info(f"STEP 2 SUCCESS: Regular database deletion completed: {db_result}")
        
        logger.info(f"=== DELETE OPERATIONS COMPLETED SUCCESSFULLY ===")
        logger.info(f"Successfully deleted document '{doc_id_pincone}' for user '{user_id}'")
        
        return {
            "status": "success",
            "message": "Document deleted successfully",
            "doc_id": doc_id_pincone,
            "vector_result": vector_result,
            "db_result": db_result
        }
        
    except InvalidRequestError as e:
        logger.error(f"DELETE FAILED: Invalid request - {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except VectorDBConnectionError as e:
        logger.error(f"DELETE FAILED: Vector database connection error - {str(e)}")
        raise HTTPException(status_code=503, detail=f"Vector database unavailable: {str(e)}")
    except DocumentStorageError as e:
        logger.error(f"DELETE FAILED: Document storage error - {str(e)}")
        raise HTTPException(status_code=503, detail=f"Storage service error: {str(e)}")
    except Exception as e:
        logger.critical(f"DELETE FAILED: Unexpected error deleting document '{doc_id_pincone}' for user '{user_id}': {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal server error during deletion")

@router.get("/get")
@limiter.limit("20/minute")
async def get_all_bookmarks(request: Request):
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized get attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")
    
    try:
        logger.info(f"Attempting to get all documents for user {user_id}")
        result = await get_all_bookmarks_from_db(user_id)
        logger.info(f"Successfully retrieved all documents for user {user_id}")
        return result
    except DocumentSaveError as e:
        logger.error(f"Document save failed for user {e.user_id}: {str(e)}", exc_info=True)
        status_code = 400 if isinstance(e, InvalidURLError) else 503
        raise HTTPException(status_code=status_code, detail=str(e))
    except ValidationError as e:
        logger.error(f"Invalid document data for user {user_id}: {str(e)}")
        raise HTTPException(status_code=422, detail="Invalid document format")  
    except Exception as e:
        logger.critical(f"Unexpected error saving document for user {user_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal server error")
    


================================================
FILE: backend/app/routers/get_quotes.py
================================================
from fastapi import APIRouter 
from app.services.quotesService import get_quotes

router = APIRouter(
    prefix="/quotes",
    tags=["quotes"]
)

@router.get("/")
async def get_random_quote():
    return get_quotes()
    



================================================
FILE: backend/app/routers/notesRouter.py
================================================
from fastapi import APIRouter, Depends , Request, HTTPException
from app.schema.notesSchema import NoteSchema
from app.services.notes_service import *
from app.exceptions.global_exceptions import create_error_response
from app.core.rate_limiter import limiter
import logging

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/notes",
    tags=["notes"]
)

@router.get("/")
@limiter.limit("20/minute")
async def get_all_notes(request: Request):
    """
    Get all notes for a user with enhanced error handling.
    """
    try:
        user_id = getattr(request.state, 'user_id', None)
        if not user_id:
            logger.warning("Unauthorized access attempt - missing user ID")
            return create_error_response(
                "Authentication required",
                status_code=401,
                error_type="auth_error"
            )

        logger.info(f"Retrieving all notes for user {user_id}")
        result = await get_all_notes_from_db(user_id)
        logger.info(f"Successfully retrieved {len(result)} notes for user {user_id}")
        return result

    except ValidationError as e:
        logger.error(f"Validation error: {str(e)}")
        return create_error_response(
            str(e),
            status_code=422,
            error_type="validation_error"
        )
    except DatabaseError as e:
        logger.error(f"Database error retrieving notes: {str(e)}")
        return create_error_response(
            "Unable to retrieve notes at this time",
            status_code=503,
            error_type="database_error"
        )
    except Exception as e:
        logger.error(f"Unexpected error retrieving notes: {str(e)}", exc_info=True)
        return create_error_response(
            "An unexpected error occurred",
            status_code=500,
            error_type="internal_error"
        )

@router.post("/")
@limiter.limit("15/minute")
async def create_new_note(note: NoteSchema, request: Request):
    """
    Create a new note for a user with enhanced error handling.
    """
    try:
        user_id = getattr(request.state, 'user_id', None)
        if not user_id:
            logger.warning("Unauthorized access attempt - missing user ID")
            return create_error_response(
                "Authentication required",
                status_code=401,
                error_type="auth_error"
            )

        logger.info(f"Creating new note for user {user_id}")
        result = await create_note(note, user_id)
        logger.info(f"Successfully created note for user {user_id}")
        return result

    except ValidationError as e:
        logger.error(f"Validation error creating note: {str(e)}")
        return create_error_response(
            str(e),
            status_code=422,
            error_type="validation_error"
        )
    except DocumentStorageError as e:
        logger.error(f"Storage error creating note: {str(e)}")
        return create_error_response(
            "Unable to save note at this time",
            status_code=503,
            error_type="storage_error"
        )
    except Exception as e:
        logger.error(f"Unexpected error creating note: {str(e)}", exc_info=True)
        return create_error_response(
            "An unexpected error occurred",
            status_code=500,
            error_type="internal_error"
        )

@router.put("/{note_id}")
@limiter.limit("15/minute")
async def update_existing_note(note_id: str, note: dict, request: Request):
    """
    Update an existing note for a user.
    """
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized update attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")
    return await update_note(note_id, note, user_id)

@router.post("/search")
@limiter.limit("15/minute")
async def search_notes_by_query(request: Request, query: str , filter: dict = None):
    """
    Search notes for a user based on a query string.
    """
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized search attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")
    return await search_notes(query=query, namespace=user_id, filter=filter)

@router.delete("/{note_id}")
@limiter.limit("15/minute")
async def delete_existing_note(request: Request, note_id: str):
    """
    Delete an existing note for a user.
    """
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        logger.warning("Unauthorized delete attempt - missing user ID")
        raise HTTPException(status_code=401, detail="Authentication required")
    return await delete_note(note_id, user_id)




================================================
FILE: backend/app/routers/summaryRouter.py
================================================
from fastapi import APIRouter, Request, HTTPException
from app.services.summariseService import *
from app.core.rate_limiter import limiter

router = APIRouter(
    prefix="/summary",
    tags=["Summary"]
)

@router.post("/generate")
@limiter.limit("5/day")
async def generate_web_summary(request: Request):
    """
    Generate a summary for the provided text.
    Rate limited to 5 requests per day per user.
    """
    data = await request.json()
    try:
        content = data.get("content")
        if not content:
            raise HTTPException(status_code=400, detail="Content is required for summarization")

        summary = await generate_summary(content)
        return {"summary": summary}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating summary: {str(e)}") from e



================================================
FILE: backend/app/schema/bookmarksSchema.py
================================================
from pydantic import BaseModel
from typing import Optional

class Memory_Schema(BaseModel):
    title: str
    user_id: str
    doc_id: str
    note: str
    site_name: str
    date: str
    source_url: str
    type: str
    space: Optional[str] = None 





================================================
FILE: backend/app/schema/link_schema.py
================================================
from pydantic import BaseModel

class Link(BaseModel):
    title: str
    note: str
    link: str
    




================================================
FILE: backend/app/schema/notesSchema.py
================================================
from pydantic import BaseModel
from typing import Optional

class NoteSchema(BaseModel):
    title: str
    note: str
    space: Optional[str] = None 


================================================
FILE: backend/app/schema/users_schema.py
================================================
[Empty file]


================================================
FILE: backend/app/services/memories_service.py
================================================
from app.core.database_wrapper import safe_collection_memories
import logging
from typing import Dict, Any
from bson.errors import InvalidId
from bson import ObjectId
from app.models.bookmarkModels import *
from pymongo.errors import PyMongoError
# Removed Memory_Schema import since we're using dict instead
from app.exceptions.databaseExceptions import *
from app.exceptions.global_exceptions import DatabaseConnectionError

logger = logging.getLogger(__name__)

async def save_memory_to_db(memory_data: dict):
    """
    Save memory data to database with enhanced error handling
    """
    try:
        # Validate memory data
        if not memory_data:
            raise MemoryValidationError("Memory data cannot be empty")

        # Additional validation checks
        if not memory_data.get("title"):
            raise MemoryValidationError("Memory must have a title")

        # Save to database using safe wrapper
        result = await safe_collection_memories.insert_one(memory_data)

        if not result.inserted_id:
            raise MemoryDatabaseError("Failed to save memory")

        # Fixed ObjectId usage
        memory_data["_id"] = str(result.inserted_id)
        logger.info(f"Successfully saved memory with id {result.inserted_id}")

        return {"status": "saved", "memory": memory_data}

    except (MemoryValidationError, MemoryDatabaseError):
        # Re-raise our custom exceptions
        raise
    except DatabaseConnectionError as e:
        logger.error(f"Database connection error: {str(e)}")
        raise MemoryDatabaseError(f"Database connection failed: {str(e)}")
    except PyMongoError as e:
        logger.error(f"Database error: {str(e)}")
        raise MemoryDatabaseError(f"Database error: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error saving memory: {str(e)}", exc_info=True)
        raise MemoryServiceError(f"Error saving memory: {str(e)}")



async def get_all_bookmarks_from_db(user_id):
    """
    Get all bookmarks for a user with enhanced error handling
    """
    try:
        if not user_id:
            raise MemoryValidationError("User ID is required")

        results = await safe_collection_memories.find({"user_id": user_id})
        return bookmarkModels(results)

    except MemoryValidationError:
        # Re-raise validation errors
        raise
    except DatabaseConnectionError as e:
        logger.error(f"Database connection error: {str(e)}")
        raise MemoryDatabaseError(f"Database connection failed: {str(e)}")
    except PyMongoError as e:
        logger.error(f"Database error: {str(e)}")
        raise MemoryDatabaseError(f"Database error: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error retrieving bookmarks: {str(e)}", exc_info=True)
        raise MemoryServiceError(f"Error retrieving bookmarks: {str(e)}")


async def delete_from_db(doc_id_pincone: str):
    """
    Delete a memory document with enhanced error handling and comprehensive logging
    """
    logger.info(f"=== DATABASE DELETE STARTED ===")
    logger.info(f"delete_from_db called with doc_id_pincone: '{doc_id_pincone}'")
    
    try:
        # Input validation with detailed logging
        if not doc_id_pincone:
            logger.error(f"VALIDATION FAILED: doc_id_pincone is empty or None: '{doc_id_pincone}'")
            raise MemoryValidationError("Document ID is required")

        logger.info(f"Input validation passed - doc_id_pincone: '{doc_id_pincone}'")
        
        # Check database connection
        logger.info("Checking database connection...")
        try:
            # Test connection with a simple operation
            await safe_collection_memories.find_one({"doc_id": doc_id_pincone})
            logger.info("Database connection successful")
        except Exception as conn_e:
            logger.error(f"Database connection test failed: {str(conn_e)}")
            raise DatabaseConnectionError(f"Failed to connect to database: {str(conn_e)}")
        
        # Perform the delete operation
        logger.info(f"Attempting to delete document with doc_id: '{doc_id_pincone}' from memories collection")
        
        result = await safe_collection_memories.delete_one({"doc_id": doc_id_pincone})
        
        logger.info(f"Database delete operation completed. Deleted count: {result.deleted_count}")
        
        if result.deleted_count == 0:
            logger.warning(f"DOCUMENT NOT FOUND: No document found with doc_id: '{doc_id_pincone}'")
            raise MemoryNotFoundError(f"Memory with id {doc_id_pincone} not found")

        logger.info(f"=== DATABASE DELETE COMPLETED SUCCESSFULLY ===")
        logger.info(f"Successfully deleted memory with id '{doc_id_pincone}' (deleted_count: {result.deleted_count})")
        
        return {"status": "deleted", "doc_id": doc_id_pincone, "deleted_count": result.deleted_count}

    except (MemoryValidationError, MemoryNotFoundError) as e:
        logger.error(f"DATABASE DELETE FAILED: {type(e).__name__} - {str(e)}")
        # Re-raise our custom exceptions
        raise
    except DatabaseConnectionError as e:
        logger.error(f"DATABASE DELETE FAILED: Database connection error - {str(e)}")
        raise MemoryDatabaseError(f"Database connection failed: {str(e)}")
    except PyMongoError as e:
        logger.error(f"DATABASE DELETE FAILED: PyMongo error - {str(e)}")
        raise MemoryDatabaseError(f"Database error: {str(e)}")
    except Exception as e:
        logger.error(f"DATABASE DELETE FAILED: Unexpected error deleting memory '{doc_id_pincone}': {str(e)}", exc_info=True)
        raise MemoryServiceError(f"Error deleting memory: {str(e)}")


================================================
FILE: backend/app/services/notes_service.py
================================================
from datetime import datetime
from typing import Optional , List, Dict
from app.core.pinecone_wrapper import safe_index, safe_pc
from app.core.database_wrapper import safe_collection_notes
from app.exceptions.httpExceptionsSave import *
from app.exceptions.httpExceptionsSearch import *
from app.exceptions.global_exceptions import ExternalServiceError, DatabaseConnectionError
from langchain_core.documents import Document
from app.models.notesModel import *
from app.utils.space_extractor import extract_space_from_text, remove_space_pattern_from_text
from app.services.pinecone_service import *

async def get_all_notes_from_db(user_id: str):
    """
    Get all notes for a user with enhanced error handling.
    """
    try:
        if not user_id:
            raise ValidationError("User ID is required")

        notes = await safe_collection_notes.find({"user_id": user_id})
        return [note_model(note) for note in notes]

    except ValidationError:
        # Re-raise validation errors
        raise
    except DatabaseConnectionError as e:
        logger.error(f"Database connection error: {str(e)}")
        raise DatabaseError(f"Database connection failed: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error retrieving notes: {str(e)}", exc_info=True)
        raise DatabaseError(f"Error retrieving notes: {str(e)}")


async def create_note(note: dict, namespace: str):
    """
    Create a new note for a user using default namespace with metadata filtering.
    """
    # Placeholder for actual implementation
    timestamp = datetime.now().strftime("%Y-%d-%m#%H-%M-%S")
    doc_id = f"{namespace}-{timestamp}"

    try:
        # Extract space from note field
        space = extract_space_from_text(note.note) or "general"
        
        # Clean the note text for embedding (remove space pattern)
        clean_note = remove_space_pattern_from_text(note.note) if note.note else note.note
        text_to_embed = f"{note.title}, {clean_note}"
        print(f"Embedding text: {text_to_embed}")
        
        # Prepare metadata with space information and namespace for filtering
        metadata = {
            "doc_id": doc_id,
            "user_id": namespace,
            "namespace": namespace,  # Add namespace to metadata for filtering
            "title": note.title,
            "note": note.note,  # Keep original note with space pattern
            "type": "Note",
            "date": datetime.now().isoformat(),
            "space": space,  # Add extracted space
        }

        # Generate embeddings using safe wrapper
        embedding = await safe_pc.embed(
            model="multilingual-e5-large",
            inputs=[text_to_embed],
            parameters={"input_type": "passage", "truncate": "END"}
        )

        vector = {
            "id": doc_id,
            "values": embedding[0]['values'],
            "metadata": metadata
        }

        # Upsert using safe wrapper - store in default namespace
        await safe_index.upsert(
            vectors=[vector]
            # No namespace parameter = default namespace
        )

        await save_note_to_db(metadata)

        return {"status": "saved", "doc_id": doc_id}

    except (ValidationError, DocumentStorageError):
        # Re-raise our custom exceptions
        raise
    except ExternalServiceError as e:
        logger.error(f"Vector database service error: {str(e)}")
        raise DocumentStorageError(
            message="Vector database service unavailable",
            user_id=namespace,
            doc_id=doc_id
        ) from e
    except Exception as e:
        logger.error(f"Unexpected error creating note: {str(e)}", exc_info=True)
        raise DocumentStorageError(
            message="Failed to save note",
            user_id=namespace,
            doc_id=doc_id
        ) from e


async def search_notes(query: str, namespace: str , filter: dict = None) -> List[Dict]:
    """
    Search notes for a user based on a query.
    """
    return await search_vector_db(
        query=query,
        namespace=namespace,
        filter=filter
    )


async def update_note(note_id: str, note: dict, user_id: str):
    """
    Update an existing note for a user.
    """
    # Placeholder for actual implementation
    note["id"] = note_id
    note["user_id"] = user_id
    return note


async def delete_note(doc_id: str, namespace: str):
    """
    Delete an existing note for a user using metadata filtering.
    """
    try:
        # Delete from vector database using metadata filtering
        vector_result = await delete_from_vector_db(doc_id, namespace)
        
        # Delete from regular database  
        db_result = await delete_note_from_db(doc_id)
        
        return {
            "status": "success",
            "message": "Note deleted successfully",
            "doc_id": doc_id,
            "vector_result": vector_result,
            "db_result": db_result
        }
        
    except Exception as e:
        logger.error(f"Error deleting note: {str(e)}", exc_info=True)
        raise DocumentStorageError(
            message="Failed to delete note",
            user_id=namespace,
            doc_id=doc_id
        ) from e

# Add the missing delete_note_from_db function
async def delete_note_from_db(doc_id: str):
    """
    Delete note from database by doc_id.
    """
    try:
        result = await safe_collection_notes.delete_one({"doc_id": doc_id})
        if result.deleted_count == 0:
            logger.warning(f"No note found with doc_id: {doc_id}")
            return {"status": "not_found", "doc_id": doc_id}
        
        return {"status": "deleted", "doc_id": doc_id, "deleted_count": result.deleted_count}
        
    except DatabaseConnectionError as e:
        logger.error(f"Database connection error: {str(e)}")
        raise DatabaseError(f"Database connection failed: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error deleting note from database: {str(e)}", exc_info=True)
        raise DatabaseError(f"Error deleting note: {str(e)}")

# ======Mongo DB Functions========

async def save_note_to_db(note_data: dict):
    """
    Save note data to the database with enhanced error handling.
    """
    try:
        if not note_data:
            raise ValidationError("Note data is required")

        print(f"Saving note to DB: {note_data}")
        result = await safe_collection_notes.insert_one(note_data)

        if not result.inserted_id:
            raise DatabaseError("Failed to save note")

        note_data["_id"] = str(result.inserted_id)
        return {"status": "saved", "note": note_data}

    except ValidationError:
        # Re-raise validation errors
        raise
    except DatabaseConnectionError as e:
        logger.error(f"Database connection error: {str(e)}")
        raise DatabaseError(f"Database connection failed: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error saving note: {str(e)}", exc_info=True)
        raise DatabaseError(f"Database error: {str(e)}")


================================================
FILE: backend/app/services/pinecone_service.py
================================================
from datetime import datetime
from typing import List, Optional, Dict
import logging
from app.core.pinecone_wrapper import safe_index, safe_pc
from langchain_core.documents import Document
from app.core.config import settings
from app.schema.link_schema import Link as LinkSchema
from app.utils.site_name_extractor import extract_site_name
from app.utils.space_extractor import extract_space_from_text, remove_space_pattern_from_text
from app.services.memories_service import save_memory_to_db
from app.exceptions.httpExceptionsSearch import *
from app.exceptions.httpExceptionsSave import *
from app.exceptions.global_exceptions import ExternalServiceError

# Configure logger
logger = logging.getLogger(__name__)

async def save_to_vector_db(obj: LinkSchema, namespace: str):
    """Save document to vector database using E5 embeddings with metadata filtering instead of namespaces"""

    # Convert timestamp to integer for cleaner ID
    timestamp = datetime.now().strftime("%Y-%d-%m#%H-%M-%S")
    doc_id = f"{namespace}-{timestamp}"

    print(f"Saving document with ID: {doc_id}")

    logger_context = {
        "user_id": namespace,
        "doc_id": doc_id,
        "url": obj.link
    }

    try:
        # Extract site name and space from note field
        site_name = await extract_site_name(obj.link) or "Unknown Site"
        space = extract_space_from_text(obj.note) or "general"  # Extract space from note field only, default to "general"
        
        # Clean the note text for embedding (remove space pattern)
        clean_note = remove_space_pattern_from_text(obj.note) if obj.note else obj.note
        text_to_embed = f"{obj.title}, {clean_note}, {site_name}"

        metadata = {
            "doc_id": doc_id,
            "user_id": namespace,
            "namespace": namespace,  # Add namespace to metadata for filtering
            "title": obj.title,
            "note": obj.note,  # Keep original note with space pattern
            "source_url": obj.link,
            "site_name": site_name,
            "type": "Bookmark",
            "date": datetime.now().isoformat(),
            "space": space, #catagory that memory belongs to 
        }

        # Generate E5 embeddings using safe wrapper
        embedding = await safe_pc.embed(
            model="multilingual-e5-large",
            inputs=[text_to_embed],
            parameters={"input_type": "passage", "truncate": "END"}
        )

        # Prepare and upsert vector
        vector = {
            "id": doc_id,
            "values": embedding[0]['values'],
            "metadata": metadata
        }

        # Upsert using safe wrapper - store in default namespace
        await safe_index.upsert(
            vectors=[vector]
            # No namespace parameter = default namespace
        )

        # Save to database
        await save_memory_to_db(metadata)

        return {"status": "saved", "doc_id": doc_id}

    except (InvalidURLError, DocumentStorageError):
        # Re-raise our custom exceptions
        raise
    except ExternalServiceError as e:
        logger.error(f"Vector database service error: {str(e)}")
        raise DocumentStorageError(
            message="Vector database service unavailable",
            user_id=namespace,
            doc_id=doc_id
        ) from e
    except Exception as e:
        logger.error("Error saving document", extra=logger_context, exc_info=True)
        raise DocumentStorageError(
            message="Failed to save document",
            user_id=namespace,
            doc_id=doc_id
        ) from e

async def search_vector_db(
    query: str,
    namespace: Optional[str],
    filter: Optional[Dict] = None,
    top_k: int = 10
) -> List[Document]:
    """Search using E5 embeddings with metadata filtering for user isolation"""

    if not namespace:
        raise InvalidRequestError("Missing user uuid - please login")

    if not query or len(query.strip()) < 3:
        raise InvalidRequestError("Search query must be at least 3 characters")

    try:
        # Extract space from query if present
        query_space = extract_space_from_text(query)
        clean_query = remove_space_pattern_from_text(query)
        
        # Create user filter using metadata
        user_filter = {"namespace": {"$eq": namespace}}
        
        # If space was extracted from query, add it to filter using proper Pinecone syntax
        if query_space:
            space_filter = {"space": {"$eq": query_space}}
            # Combine user filter, space filter and existing filters
            filters_to_combine = [user_filter, space_filter]
            if filter:
                filters_to_combine.append(filter)
            filter = {"$and": filters_to_combine}
        else:
            # Just combine user filter with existing filter if present
            if filter:
                filter = {"$and": [user_filter, filter]}
            else:
                filter = user_filter
        
        # Generate query embedding using clean query (without space pattern)
        embedding = await safe_pc.embed(
            model="multilingual-e5-large",
            inputs=[clean_query],
            parameters={"input_type": "query", "truncate": "END"}
        )

        # Perform vector search using safe wrapper - search in default namespace with metadata filter
        results = await safe_index.query(
            vector=embedding[0]['values'],
            top_k=top_k,
            include_metadata=True,
            filter=filter
            # No namespace parameter = search in default namespace
        )

        # Convert to Langchain documents format
        documents = []

        if documents is None:
            print("No documents found in the search results")

        for match in results['matches']:
            doc_id = match['id']
            metadata = match['metadata']
            print(f"{namespace} , Processing document ID: {doc_id} with metadata: {metadata}")


            if metadata.get('type') == 'Bookmark':
                # Clean the note content for display (remove space pattern)
                clean_note = remove_space_pattern_from_text(metadata['note'])
                documents.append(Document(
                id=doc_id,
                page_content=f"Title: {metadata['title']}\nNote: {clean_note}\nSource: {metadata['source_url']}",
                metadata=metadata
            ))

            else:
                # For notes, clean the note content for display (remove space pattern)
                clean_note = remove_space_pattern_from_text(metadata['note'])
                documents.append(Document(
                id=doc_id,
                page_content=f"Title: {metadata['title']}\nNote: {clean_note}",
                metadata=metadata
            ))

        if not documents:
            raise SearchExecutionError("No documents found matching query")

        return documents

    except (InvalidRequestError, SearchExecutionError):
        # Re-raise our custom exceptions
        raise
    except ExternalServiceError as e:
        logger.error(f"Vector database service error: {str(e)}")
        raise SearchExecutionError(f"Vector database service unavailable: {str(e)}")
    except Exception as e:
        logger.error("Search failed", extra={"user_id": namespace}, exc_info=True)
        return []  # Return empty list if search fails gracefully

async def delete_from_vector_db(doc_id: str, namespace: str):
    """
    Delete document from vector database using metadata filtering instead of namespace isolation
    """
    logger.info(f"=== VECTOR DB DELETE STARTED ===")
    logger.info(f"delete_from_vector_db called with doc_id: '{doc_id}', namespace: '{namespace}'")
    
    try:
        # Input validation with detailed logging
        if not doc_id:
            logger.error(f"VALIDATION FAILED: doc_id is empty or None: '{doc_id}'")
            raise InvalidRequestError("Document ID is required")
        if not namespace:
            logger.error(f"VALIDATION FAILED: namespace is empty or None: '{namespace}'")
            raise InvalidRequestError("Namespace is required")
            
        logger.info(f"Input validation passed - doc_id: '{doc_id}', namespace: '{namespace}'")
        
        # Check vector database connection
        logger.info("Checking vector database connection...")
        try:
            # Test connection with index stats
            stats = await safe_index.describe_index_stats()
            logger.info(f"Vector DB connection successful. Index stats: {stats}")
        except Exception as conn_e:
            logger.error(f"Vector DB connection test failed: {str(conn_e)}")
            raise VectorDBConnectionError(f"Failed to connect to vector database: {str(conn_e)}")
        
        # Create metadata filter to ensure we only delete documents belonging to this user
        delete_filter = {
            "$and": [
                {"namespace": {"$eq": namespace}},
                {"doc_id": {"$eq": doc_id}}
            ]
        }
        
        # Perform the delete operation using metadata filter instead of namespace
        logger.info(f"Attempting to delete vector with id: '{doc_id}' for user: '{namespace}' using metadata filter")
        
        delete_result = await safe_index.delete(
            filter=delete_filter
            # No namespace parameter = delete from default namespace using filter
        )
        
        logger.info(f"Vector database delete operation completed. Result: {delete_result}")
        logger.info(f"=== VECTOR DB DELETE COMPLETED SUCCESSFULLY ===")
        
        return {"status": "deleted", "doc_id": doc_id, "namespace": namespace, "delete_result": delete_result}

    except InvalidRequestError as e:
        logger.error(f"VECTOR DB DELETE FAILED: Validation error - {str(e)}")
        # Re-raise validation errors
        raise
    except VectorDBConnectionError as e:
        logger.error(f"VECTOR DB DELETE FAILED: Connection error - {str(e)}")
        raise
    except ExternalServiceError as e:
        logger.error(f"VECTOR DB DELETE FAILED: External service error - {str(e)}")
        raise DocumentStorageError(
            message="Vector database service unavailable",
            user_id=namespace,
            doc_id=doc_id
        ) from e
    except Exception as e:
        logger.error(f"VECTOR DB DELETE FAILED: Unexpected error - doc_id: '{doc_id}', namespace: '{namespace}', error: {str(e)}", exc_info=True)
        raise DocumentStorageError(
            message="Failed to delete document from vector database",
            user_id=namespace,
            doc_id=doc_id
        ) from e


================================================
FILE: backend/app/services/quotesService.py
================================================
from app.utils.quotes_dict import quotes
import random

def get_quotes():
    return quotes


================================================
FILE: backend/app/services/summariseService.py
================================================
from langchain_google_genai import GoogleGenerativeAI
from langchain_core.messages import SystemMessage
from google.generativeai.types.safety_types import HarmBlockThreshold, HarmCategory

async def generate_summary(text: str) -> str:
    llm = GoogleGenerativeAI(
        model="gemini-2.0-flash",
        temperature=0.7,
        max_output_tokens=8000,
        top_p=0.95,
        top_k=10,
        safety_settings={
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_NONE,
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_NONE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_NONE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_NONE,
        }
    )

    system_message = SystemMessage(
        content= f"""
            ROLE: You are an Expert Content Extraction and Semantic Summarization AI.
            TASK:
            You will be provided with scraped website data (HTML, and potentially CSS/JS). Your objective is to:
            - Identify and extract the primary informational content of the page.
            - Systematically ignore non-essential elements (navigation, footers, ads, boilerplate, etc.).
            - Synthesize the extracted information into a concise, well-structured, hierarchical summary.
            INPUT:
            - The scraped website data will be provided below under "[[SCRAPED_WEBSITE_DATA]]".
            PROCESSING INSTRUCTIONS:
            Content Focus:
            - Prioritize textual content found within main content areas of the HTML (e.g., <article>, <main>, or divs that appear to hold primary content based on structure and class names).
            - Extract headings (H1-H6), paragraphs (P), lists (UL, OL, LI), table data (TABLE, TH, TR, TD), and definition lists (DL, DT, DD).
            - Pay attention to emphasized text (STRONG, EM, B, I) as it might indicate key points.
            - Exclusion Criteria (CRITICAL - IGNORE these unless they contain unique, primary informational content directly contributing to the page's main topic):
            - Navigation elements: Menus, breadcrumbs, pagination (<nav>, common header/footer links).
            - Sidebars (<aside>) containing primarily links, ads, or tangential information.
            - Footers (<footer>) containing copyright, generic links, or site-wide boilerplate.
            - Advertisements and promotional banners.
            - Cookie consent banners and privacy pop-ups.
            - Image carousels or galleries without substantial descriptive text accompanying each image.
            - Social media sharing widgets or feeds.
            - User interface elements not directly part of the content (e.g., search bars themselves, decorative icons, "skip to content" links).
            - Forms (e.g., contact forms, login forms) unless the surrounding text provides critical context for the page's topic.
            - Redundant links or calls to action repeated throughout the page.
            - CSS and JavaScript code: Do not interpret or execute. Only extract text if it's explicitly embedded as content (e.g., within a <script> tag that is clearly a data block, or an ARIA label that provides essential description not found elsewhere).
            - Structure and Hierarchy Inference:
            - Use HTML heading tags (H1-H6) as the primary basis for the summary's structure.
            - Infer logical groupings and sub-sections even if formal heading tags are sparse, based on visual separation implied by divs or semantic tags.
            - Crucially, only include a heading in the summary if there is substantive, relevant textual content to list or describe beneath it after applying exclusion criteria. Do not create empty sections or headings with only one or two generic, non-informative points.
            - Summarization and Synthesis:
            - Condense extracted information. Paraphrase where necessary for brevity but retain meaning.
            - Group related points under appropriate topics and subtopics.
            - Aim for a summary that captures the essence and key takeaways of the page's informational content.
            - Discard purely navigational text, repetitive boilerplate, or marketing fluff that doesn't add informational value.
            OUTPUT REQUIREMENTS:
            - Format: Structured Markdown.
            Content Structure:
            - Begin with a primary heading (H1 or H2) that best represents the overall page title or main subject.
            - Organize the summary using subsequent Markdown headings (H2, H3, H4) to represent major sections and topics.
            - Under each heading, use nested bullet points (* or -) or numbered lists for specific details, key points, subtopics, or data.
            - Ensure a logical flow and clear hierarchy.
            - Omit any section/heading if no meaningful content points can be extracted for it after filtering. Avoid empty sections.
            Strict Adherence:
            - PRODUCE ONLY THE SUMMARY.
            - NO introductory phrases (e.g., "Here is the summary:").
            - NO explanations of your methodology or challenges.
            - NO disclaimers about content accuracy or completeness.
            - NO concluding remarks or sign-offs.

            Your entire response must be the structured Markdown summary itself.

            [[SCRAPED_WEBSITE_DATA]] : {text}
            """
    )

    try:
        response = llm.invoke([system_message])
        return response

    except Exception as e:
        print(f"Error occurred: {e}")
        return "Error occurred while generating summary."
# Example usage:



================================================
FILE: backend/app/services/user_service.py
================================================
from app.core.database import collection
import logging

logger = logging.getLogger(__name__)


async def create_user_if_not_exists(data: dict):
    """
    Create a user if they do not exist in the database.
    """
    logger.info(f"👤 USER SERVICE: Checking/creating user from JWT payload")
    
    # Extract data from the decoded JWT
    user_id = data.get("sub")
    email = data.get("email")
    role = data.get("role")
    created_at = data.get("created_at")
    last_sign_in_at = data.get("updated_at")  # Last sign-in is "updated_at"
    issuer = data.get("iss")  # Top-level claim

    logger.info(f"   ├─ User ID: {user_id}")
    logger.info(f"   ├─ Email: {email}")
    logger.info(f"   ├─ Role: {role}")
    logger.info(f"   ├─ Issuer: {issuer}")
    logger.info(f"   ├─ Created at: {created_at}")
    logger.info(f"   └─ Last sign in: {last_sign_in_at}")

    # User metadata (e.g., name, picture)
    user_metadata = data.get("user_metadata", {})
    full_name = user_metadata.get("full_name")
    picture = user_metadata.get("picture")
    
    logger.info(f"   ├─ Full name: {full_name}")
    logger.info(f"   └─ Picture present: {bool(picture)}")

    # App metadata (e.g., auth provider)
    app_metadata = data.get("app_metadata", {})
    provider = app_metadata.get("provider")
    providers = app_metadata.get("providers")
    
    logger.info(f"   ├─ Provider: {provider}")
    logger.info(f"   └─ Providers: {providers}")

    # Combine into user_data
    user_data = {
        "id": user_id,
        "email": email,
        "role": role,
        "created_at": created_at,
        "last_sign_in_at": last_sign_in_at,
        "issuer": issuer,
        "full_name": full_name,
        "picture": picture,
        "provider": provider,
        "providers": providers
    }

    logger.info(f"🔍 USER SERVICE: Checking if user exists in database")
    if not await user_exists(user_id):
        logger.info(f"➕ USER SERVICE: User not found, creating new user")
        await create_user(user_data)
        logger.info(f"✅ USER SERVICE: New user created successfully")
    else:
        logger.info(f"✅ USER SERVICE: User already exists, skipping creation")
    
    return user_data


async def user_exists(user_id: str):
    logger.info(f"🔍 USER SERVICE: Checking if user exists")
    logger.info(f"   └─ User ID: {user_id}")
    
    query = collection.find_one({"id": user_id})
    exists = query is not None
    
    logger.info(f"   └─ User exists: {exists}")
    if exists:
        logger.info(f"   └─ Found user data keys: {list(query.keys()) if query else 'None'}")
    
    return exists


async def create_user(user_data: dict):
    logger.info(f"➕ USER SERVICE: Creating new user in database")
    logger.info(f"   ├─ User ID: {user_data.get('id')}")
    logger.info(f"   ├─ Email: {user_data.get('email')}")
    logger.info(f"   ├─ Full name: {user_data.get('full_name')}")
    logger.info(f"   └─ Data keys: {list(user_data.keys())}")
    
    try:
        result = collection.insert_one(user_data)
        logger.info(f"✅ USER SERVICE: User created successfully")
        logger.info(f"   ├─ Inserted ID: {result.inserted_id}")
        logger.info(f"   └─ Acknowledged: {result.acknowledged}")
        return user_data
    except Exception as e:
        logger.error(f"❌ USER SERVICE: Failed to create user in database")
        logger.error(f"   ├─ Error type: {type(e).__name__}")
        logger.error(f"   ├─ Error message: {str(e)}")
        logger.error(f"   └─ This may cause issues with user data persistence")
        raise

    


================================================
FILE: backend/app/utils/jwt.py
================================================
from jose import jwt, JWTError, ExpiredSignatureError
from app.core.config import settings
from fastapi import HTTPException, status
import httpx
import logging

logger = logging.getLogger(__name__)


class TokenExpiredError(Exception):
    """Custom exception for expired tokens that can be refreshed"""
    pass

async def decodeJWT(access_token: str) -> dict:
    """
    Decode Supabase JWT token using the proper JWT secret
    """
    logger.info(f"🔑 JWT DECODE: Starting JWT token validation")
    
    # Clean the token input
    original_token_length = len(access_token) if access_token else 0
    access_token = access_token.strip()
    logger.info(f"   ├─ Original token length: {original_token_length}")
    logger.info(f"   ├─ Cleaned token length: {len(access_token)}")
    
    # Remove Bearer prefix if present
    if access_token.lower().startswith("bearer "):
        access_token = access_token[7:].strip()
        logger.info(f"   ├─ Removed Bearer prefix, final length: {len(access_token)}")

    if not access_token:
        logger.error(f"❌ JWT DECODE: Empty access token after cleaning")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing access token"
        )

    # Use the proper JWT secret for Supabase tokens
    jwt_secret = settings.SUPABASE_JWT_SECRET.strip()
    logger.info(f"   ├─ JWT secret configured: {bool(jwt_secret)}")
    logger.info(f"   ├─ JWT secret length: {len(jwt_secret) if jwt_secret else 0}")
    
    if not jwt_secret:
        logger.error("❌ JWT DECODE: Supabase JWT secret is missing in configuration")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Server configuration error"
        )

    expected_audience = "authenticated"
    expected_issuer = f"{settings.SUPABASE_URL}/auth/v1"
    logger.info(f"   ├─ Expected audience: {expected_audience}")
    logger.info(f"   ├─ Expected issuer: {expected_issuer}")
    logger.info(f"   └─ Supabase URL: {settings.SUPABASE_URL}")

    try:
        logger.info(f"🔍 JWT DECODE: Attempting to decode token with HS256 algorithm")
        # Decode with Supabase-specific settings
        payload = jwt.decode(
            token=access_token,
            key=jwt_secret,
            algorithms=["HS256"],
            options={
                "verify_signature": True,
                "verify_aud": True,  # Supabase tokens have audience
                "verify_exp": True,
                "verify_iss": True,  # Supabase tokens have issuer
            },
            # Expected audience and issuer for Supabase
            audience=expected_audience,
            issuer=expected_issuer
        )

        logger.info(f"✅ JWT DECODE: Token decoded successfully")
        logger.info(f"   ├─ Payload keys: {list(payload.keys())}")
        logger.info(f"   ├─ Subject (user_id): {payload.get('sub', 'Missing')}")
        logger.info(f"   ├─ Email: {payload.get('email', 'Missing')}")
        logger.info(f"   ├─ Audience: {payload.get('aud', 'Missing')}")
        logger.info(f"   ├─ Issuer: {payload.get('iss', 'Missing')}")
        logger.info(f"   ├─ Issued at: {payload.get('iat', 'Missing')}")
        logger.info(f"   └─ Expires at: {payload.get('exp', 'Missing')}")

        # Validate required claims
        if 'sub' not in payload:
            logger.warning("❌ JWT DECODE: Token missing subject (user ID)")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing user ID"
            )

        if 'exp' not in payload:
            logger.warning("❌ JWT DECODE: Token missing expiration claim")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has no expiration"
            )

        logger.info(f"✅ JWT DECODE: All required claims validated successfully")
        return payload

    except ExpiredSignatureError as e:
        logger.warning(f"⏰ JWT DECODE: Token has expired: {str(e)}")
        logger.warning(f"   └─ Raising TokenExpiredError for refresh handling")
        raise TokenExpiredError("Token has expired")
    except JWTError as e:
        logger.warning(f"❌ JWT DECODE: JWT decoding failed: {str(e)}")
        logger.warning(f"   ├─ Error type: {type(e).__name__}")
        logger.warning(f"   └─ This indicates token format or signature issues")
        # Enhanced error diagnostics
        debug_info = {
            "token_length": len(access_token),
            "secret_configured": bool(jwt_secret),
            "algorithm": "HS256",
            "expected_audience": expected_audience,
            "expected_issuer": expected_issuer
        }
        logger.debug(f"🔍 JWT DECODE: Debug info: {debug_info}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid token: {str(e)}"
        )
    except Exception as e:
        logger.error(f"💥 JWT DECODE: Unexpected error during JWT decoding: {str(e)}")
        logger.error(f"   ├─ Error type: {type(e).__name__}")
        logger.error(f"   └─ This is likely a configuration or system error")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Token validation error"
        )
    


async def refresh_access_token(refresh_token: str) -> dict:
    """
    Refresh access token using Supabase refresh token
    Returns new access token and refresh token
    """
    logger.info(f"🔄 TOKEN REFRESH: Starting token refresh process")
    
    if not refresh_token or not refresh_token.strip():
        logger.error("❌ TOKEN REFRESH: Empty refresh token provided")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    refresh_token = refresh_token.strip()
    logger.info(f"   ├─ Refresh token length: {len(refresh_token)}")
    logger.info(f"   ├─ Refresh token prefix: {refresh_token[:8]}...")
    
    # Use the correct Supabase refresh token endpoint format
    url = f"{settings.SUPABASE_URL}/auth/v1/token?grant_type=refresh_token"
    logger.info(f"   ├─ Refresh endpoint: {url}")
    logger.info(f"   ├─ Supabase URL: {settings.SUPABASE_URL}")
    logger.info(f"   └─ Grant type: refresh_token")
    
    headers = {
        "apikey": settings.SUPABASE_ANON_KEY,
        "Content-Type": "application/json"
    }
    logger.info(f"🌐 TOKEN REFRESH: Preparing request headers")
    logger.info(f"   ├─ API key configured: {bool(settings.SUPABASE_ANON_KEY)}")
    logger.info(f"   ├─ API key length: {len(settings.SUPABASE_ANON_KEY) if settings.SUPABASE_ANON_KEY else 0}")
    logger.info(f"   └─ Content-Type: application/json")
    
    data = {
        "refresh_token": refresh_token
    }

    async with httpx.AsyncClient(timeout=10.0) as client:
        try:
            logger.info(f"📡 TOKEN REFRESH: Sending refresh request to Supabase")
            logger.info(f"   ├─ Timeout: 10.0 seconds")
            logger.info(f"   └─ Request payload keys: {list(data.keys())}")
            
            response = await client.post(url, headers=headers, json=data)
            
            # Log response details for debugging
            logger.info(f"📨 TOKEN REFRESH: Response received from Supabase")
            logger.info(f"   ├─ Response status: {response.status_code}")
            logger.info(f"   ├─ Response headers: {list(response.headers.keys())}")
            logger.info(f"   └─ Response size: {len(response.content)} bytes")
            
            if response.status_code == 200:
                logger.info(f"✅ TOKEN REFRESH: Successful response from Supabase")
                token_data = response.json()
                
                logger.info(f"🔍 TOKEN REFRESH: Validating response structure")
                logger.info(f"   ├─ Response keys: {list(token_data.keys())}")
                
                # Validate response structure
                if "access_token" not in token_data:
                    logger.error(f"❌ TOKEN REFRESH: Invalid refresh response structure")
                    logger.error(f"   ├─ Expected 'access_token' key missing")
                    logger.error(f"   └─ Available keys: {list(token_data.keys())}")
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail="Invalid refresh token response from auth service"
                    )
                
                # Log token information (without exposing full tokens)
                new_access_token = token_data.get("access_token", "")
                new_refresh_token = token_data.get("refresh_token", "")
                expires_in = token_data.get("expires_in", "Unknown")
                token_type = token_data.get("token_type", "Bearer")
                
                logger.info(f"🎯 TOKEN REFRESH: New tokens received")
                logger.info(f"   ├─ New access token length: {len(new_access_token)}")
                logger.info(f"   ├─ New refresh token length: {len(new_refresh_token)}")
                logger.info(f"   ├─ Token type: {token_type}")
                logger.info(f"   ├─ Expires in: {expires_in} seconds")
                logger.info(f"   └─ Refresh token changed: {new_refresh_token != refresh_token}")
                
                logger.info("✅ TOKEN REFRESH: Token refresh completed successfully")
                return token_data
            else:
                # Handle error responses
                error_text = response.text
                logger.error(f"❌ TOKEN REFRESH: Supabase refresh failed")
                logger.error(f"   ├─ Status code: {response.status_code}")
                logger.error(f"   ├─ Error response: {error_text[:200]}...")
                logger.error(f"   └─ Full response size: {len(error_text)} characters")
                
                try:
                    error_json = response.json()
                    error_code = error_json.get("error", "unknown_error")
                    detail = error_json.get("error_description", error_json.get("msg", "Invalid refresh token"))
                    logger.error(f"   ├─ Error code: {error_code}")
                    logger.error(f"   └─ Error description: {detail}")
                except Exception as json_error:
                    logger.error(f"   └─ Could not parse error JSON: {str(json_error)}")
                    detail = "Invalid refresh token"
                
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail=detail
                )
            
        except httpx.HTTPStatusError as e:
            logger.error(f"❌ TOKEN REFRESH: HTTP status error during refresh")
            logger.error(f"   ├─ Error type: {type(e).__name__}")
            logger.error(f"   ├─ Status code: {e.response.status_code if e.response else 'Unknown'}")
            logger.error(f"   └─ Error message: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token refresh failed"
            )
        except httpx.RequestError as e:
            logger.error(f"💥 TOKEN REFRESH: Request error - auth service unavailable")
            logger.error(f"   ├─ Error type: {type(e).__name__}")
            logger.error(f"   ├─ Error message: {str(e)}")
            logger.error(f"   └─ This indicates network or service issues")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Authentication service is unavailable"
            )


# Legacy function for backward compatibility
async def verify_and_refresh_token(access_token: str, refresh_token: str) -> dict:
    """
    Legacy function - use refresh_access_token instead
    """
    return await refresh_access_token(refresh_token)


================================================
FILE: backend/app/utils/quotes_dict.py
================================================
quotes = [
  "The key is not to prioritize what's on your schedule, but to schedule your priorities.",
  "Focus on being productive instead of busy.",
  "Productivity comes from commitment to excellence, planning, and focused effort.",
  "Concentrate your thoughts on work. The sun's rays only burn when focused.",
  "Focus does not mean saying yes, it means saying no.",
  "Don't dwell in past or worry about future, focus on living in the present.",
  "Failure isn't fatal, but failure to change might be.",
  "Everything you want is on the other side of fear.",
  "The secret of life is to fall seven times and to get up eight times.",
  "Success is not final, failure is not fatal: it is the courage to continue that counts.",
  "Let improving yourself keep you too busy to criticize others.",
  "Work hard and have fun in what you do to be more successful.",
  "Glory lies not in never falling, but in rising every time we fall.",
  "Do what you believe is great work to be truly satisfied.",
  "Don't watch the clock; do what it does. Keep going.",
  "The future depends on what you do today.",
  "It's not about having enough time, it's about making enough time.",
  "The only place where success comes before work is in the dictionary.",
  "Don't be afraid to give up the good to go for the great.",
  "Discipline is the bridge between goals and accomplishment.",
  "Eliminate inefficient use of information, energy, and time to become more productive.",
  "You don't have to see the whole staircase, just take the first step.",
  "Amateurs wait for inspiration, the rest of us just go to work.",
  "You miss 100% of the shots you don't take.",
  "The harder you work, the greater you'll feel when you achieve it.",
  "There are no shortcuts to any place worth going.",
  "Our only limit to tomorrow will be our doubts of today.",
  "Act as if what you do makes a difference. It does.",
  "Judge days by the seeds you plant, not the harvest you reap.",
  "The successful warrior is the average man, with laser-like focus.",
  "Success is stumbling from failure to failure with no loss of enthusiasm.",
  "Our greatest weakness is giving up. Success comes from trying one more time.",
  "The way to get started is to quit talking and begin doing.",
  "Either you run the day or the day runs you.",
  "Start where you are. Use what you have. Do what you can.",
  "The difference between ordinary and extraordinary is that little extra.",
  "The question isn't who will let me; it's who will stop me.",
  "Don't count the days, make the days count.",
  "Quality is not an act, it is a habit.",
  "Will you let obstacles stop you? That's the real question.",
  "It always seems impossible until it's done.",
  "The path to success is to take massive, determined action.",
  "If you're going through hell, keep going.",
  "The only way to do great work is to love what you do.",
  "You'll regret the things you didn't do more than the ones you did.",
  "You become what you believe.",
  "The best way to predict the future is to create it.",
  "Believe you can and you're halfway there.",
  "Don't waste time living someone else's life.",
  "Success is making a positive difference to the world."
]


================================================
FILE: backend/app/utils/site_name_extractor.py
================================================
from urllib.parse import urlparse

async def extract_site_name(url: str) -> str:
    # Add scheme if missing
    if not url.startswith(("http://", "https://")):
        url = "http://" + url
    
    parsed = urlparse(url)
    domain = parsed.netloc  # This gives everything between // and the next /
    
    # Remove www prefix if present
    if domain.startswith("www."):
        domain = domain[4:]
    
    return domain


================================================
FILE: backend/app/utils/space_extractor.py
================================================
import re
from typing import Optional
import logging

logger = logging.getLogger(__name__)

def extract_space_from_text(text: Optional[str]) -> Optional[str]:
    """
    Extract space name from text using the pattern #spacename:
    
    Args:
        text: The text to search for space pattern
        
    Returns:
        The extracted space name or None if no pattern found
        
    Examples:
        extract_space_from_text("This is about #books: machine learning") -> "books"
        extract_space_from_text("Regular text without pattern") -> None
        extract_space_from_text("#music: my favorite songs") -> "music"
    """
    if not text or not isinstance(text, str):
        return None
    
    # Pattern to match #spacename: where spacename can contain letters, numbers, underscores, hyphens
    pattern = r'#([a-zA-Z0-9_-]+):'
    
    try:
        match = re.search(pattern, text.strip())
        if match:
            space_name = match.group(1).lower().strip()
            # Validate space name (basic validation)
            if len(space_name) > 0 and len(space_name) <= 50:
                logger.info(f"Extracted space: '{space_name}' from text")
                return space_name
            else:
                logger.warning(f"Invalid space name length: '{space_name}'")
                return None
        return None
    except Exception as e:
        logger.error(f"Error extracting space from text: {str(e)}")
        return None

def remove_space_pattern_from_text(text: Optional[str]) -> Optional[str]:
    """
    Remove space pattern from text for clean searching
    
    Args:
        text: The text to clean
        
    Returns:
        Text with space pattern removed
        
    Examples:
        remove_space_pattern_from_text("This is about #books: machine learning") -> "This is about machine learning"
    """
    if not text or not isinstance(text, str):
        return text
    
    # Pattern to match #spacename: 
    pattern = r'#[a-zA-Z0-9_-]+:\s*'
    
    try:
        cleaned_text = re.sub(pattern, '', text).strip()
        return cleaned_text if cleaned_text else text
    except Exception as e:
        logger.error(f"Error removing space pattern from text: {str(e)}")
        return text 


================================================
FILE: frontend/README.md
================================================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```



================================================
FILE: frontend/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)



================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: frontend/package.json
================================================
{
  "name": "extension",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build && node scripts/replace-env-vars.mjs",
    "build:base": "tsc -b && vite build",
    "postbuild": "node scripts/replace-env-vars.mjs",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.49.8",
    "@tailwindcss/line-clamp": "^0.4.4",
    "dotenv": "^17.0.0",
    "framer-motion": "^12.4.2",
    "is-url-http": "^2.3.9",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.4.0",
    "react-markdown": "^10.1.0",
    "react-router-dom": "^7.1.5",
    "remark-gfm": "^4.0.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.19.0",
    "@types/chrome": "^0.0.304",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.19.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.18",
    "globals": "^15.14.0",
    "postcss": "^8.5.2",
    "tailwindcss": "^3.4.17",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.22.0",
    "vite": "^6.1.0"
  }
}



================================================
FILE: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      fontFamily:{
        SansMono400:['Sans-Mono-400','sans-serif'],
        SansMono500:['Sans-Mono-500','sans-serif'],
        SansMono700:['Sans-Mono-700','sans-serif'],
        SansText400:['Sans-Text-400','sans-serif'],
        SansText700:['Sans-Text-700','sans-serif'],
        NanumMyeongjo:['Nanum Myeongjo','sans-serif'],
      },
      colors: {
        // Greens
        'custom-lime': '#e5ff59',
        'custom-green': '#48f08b',
        'custom-lime-yellow': '#daef68',
        'custom-electric-lime': '#d7ff40',
        'custom-neon-green': '#39ff88',
        'custom-chartreuse': '#dfff00',
        
        // Purples
        'custom-light-violet': '#c7b0ff',
        'custom-violet': '#8f9aff',
        'custom-bright-purple': '#bb94ff',
        
        // Pinks
        'custom-light-pink': '#ffb1ee',
        'custom-hot-pink': '#ff7aeb',
        
        // Blues
        'custom-blue': '#007aff',
        'custom-electric-blue': '#6cacff',
        'custom-vivid-blue': '#008cff',
        
        // Oranges
        'custom-orange': '#ff8e59',
        'custom-brownish-orange': '#eebc41',
        'custom-bright-orange': '#ff7b00',
        'custom-marigold': '#ffba00',
        
        // Yellows
        'custom-yellow': '#fcfd54',
        'custom-bright-yellow': '#fffa33',
        'rich-burgundy': '#9b1a1b',
      },
    },
  },
  plugins: [
    require('@tailwindcss/line-clamp')
  ],
}


================================================
FILE: frontend/trial.txt
================================================
index-DYwxReYX.js:117 Extracted content: .snoo-cls-1 { fill: url(#snoo-radial-gragient) white; } .snoo-cls-1, .snoo-cls-2, .snoo-cls-3, .snoo-cls-4, .snoo-cls-5, .snoo-cls-6, .snoo-cls-7, .snoo-cls-8, .snoo-cls-9, .snoo-cls-10, .snoo-cls-11 { stroke-width: 0px; } .snoo-cls-2 { fill: url(#snoo-radial-gragient-2) white; } .snoo-cls-3 { fill: url(#snoo-radial-gragient-3) white; } .snoo-cls-4 { fill: url(#snoo-radial-gragient-4) #fc4301; } .snoo-cls-5 { fill: url(#snoo-radial-gragient-6) black; } .snoo-cls-6 { fill: url(#snoo-radial-gragient-8) black; } .snoo-cls-7 { fill: url(#snoo-radial-gragient-5) #fc4301; } .snoo-cls-8 { fill: url(#snoo-radial-gragient-7) white; } .snoo-cls-9 { fill: #842123; } .snoo-cls-10 { fill: #ff4500; } .snoo-cls-11 { fill: #ffc49c; }
Log In
r/CasualConversation
MaximumEase5797
Just Chatting
For me it was finally negotiating rent on my own apartment for the first time. I know that sounds very basic to some of you, but I've been living with roommates for such a long time and there was always someone else who handled the "business" side of things. But last month I found this place I really wanted and had to deal with the landlord directly. The initial asking price was way more than I wanted to pay, and old me would have just walked away or accepted it. But something clicked and I actually researched comparable rents in the area, put together a little presentation on my phone with screenshots and asked if we could negotiate a price which suits as both.
I wasn't aggressive about it like I just laid out some screenshots of places close by and why I thought the price was high and what I could realistically afford. Turned out the place had been sitting empty for two months and they were motivated to fill it. We settled on something $200 less than asking and they agreed to cover utilities for the first six months. Walking out of there with keys in my hand and knowing I did this all myself I don't know I just felt something that I've never ever felt in my life. I can't really explain it with words. The apartment isn't fancy but it's mine at least. No shared kitchen drama, no arguing and just full privacy.
What about you all? What made you feel like you'd finally figured out something like this?
ZebbianaHeart
5h ago
advocating for your own needs, especially in a high-stakes situation like housing, takes real maturity.
laurenfcp
Handled something for my parents- usually they handle things for me
Elastichedgehog
It was incredibly jarring when my parents asked me for advice during the pandemic about what they should do.
nice!
PrettyDreamybabe
booked my own doctor’s appointment
Ohsweetmelanie
Interestingly, this seems to be a thing for you young folks. When my daughter kept asking me to do some of these things for her, I blamed myself. Then it dawned on me that social media really has stripped many of you guys who grew up with it of your voice. And thats nothing bad against you guys. Its more just an observation of what objects, technology, etc can do in shifting how we live, learn, communicate, date, work, etc, etc.
When I figured this out with my own daughter, all that became very eye-opening to me. It honestly kind of made me sad for you younger adults bc it means you have to work twice as hard to ramp up to accomplish some things. So I am very proud of you on your accomplishment with this. Doesn't seem like it would've been a big deal 40 years ago, but it is today!
2 more replies
Vast_Reflection
Realizing that if I want to do something with my life, I actually have to put the effort in. Obviously I’ve known that forever, but I guess I emotionally understand it more? I could put the blame on my relationships for not encouraging or inspiring me and dragging me down, or I could face the fact that even without relationships in my life, I’d probably be in the same place.
I started taking a class where there’s several people twice my age and still in the beginner stages, and honestly that made me think - if they can commit to this, even though they know their bodies aren’t always going to cooperate and that they might never see the finish line, maybe I could actually turn my life around.
I don’t know where I’m going yet, but I finally feel like I can, rather than discouraged that I haven’t yet, if that makes sense. I might be “behind” in a way, but that doesn’t mean I can’t start now.
LethalLlama478
I got a 3 day to pay or vacate notice.
I miss the good old days where money wasn’t tight and I didn’t feel like I was just simply surviving.
A sense of pride and accomplishment, huh? That's awesome, and an awesome feeling when it happens! I don't know ya but im proud of you! Congrats on your new place!
Elegant-Expert7575
Just bought a brand new vehicle and had it financed from the dealership entirely on my own, no help. No second hand car lot. No settling for a vehicle I didn’t want. Every single feature you could think of. Like you, it’s probably something many have done a million times over, but I never have.And, I’m 55. :)
TheReader016
4h ago
Pay for my own bills, buy my own grocer, Do errands on my own, decision making on a daily life
Wumutissunshinesmile
Wow that's really good to get so much off! ☺️
Hmm, I went to a job interview and got told on spot I wasn't the right fit and the guy went on for 5 minutes about why and I felt a little upset like I wanted to cry. But I held back and he said he didn't want to make me think I had a chance and wanted just to be honest. I thanked him for his honesty rather than get upset. I said I wish more people were like that. I sort of do. Funny thing is I read bad reviews about working there but still felt kinda sad to be told so quickly. But also looked back at job description and he half of what he told me the job wasn't was a lie as it said the job entailed it. He said I seemed lovely though and if it was a different job I'd have got it maybe. I wondered after if maybe he too thought it a bad place to work too and thought I was nice and didn't want me to work there and that's really it. Could be wrong ofc. But it was all very strange. Never had an interview like it.
Hungry_Raccoon_4364
I went to a planning committee meeting at my city. I have been trying to arrange a meeting with the mayor and council person for my district… and in the background, inciting the rest of the neighborhood to unit write emails and even… dare I say… protest… I feel like such a Norma Rae…
SparkleStorm93
Making the decision to end my relationship with my partner of 6 years. We have a daughter together, and have known each other 20 years. Without a doubt the biggest decision I’ve ever had to make.
kelpiekid
Our walk-in closet has been a mess since the day we moved in, with clothes and bags absolutely everywhere, on the floor, with no sense of organization. It caused me so much unnecessary stress, and often chose to wear less work appropriate clothes just so I didn't have to go in the closet.
I finally got the energy, we went through our clothes to donate some, and i bought some crappy bins and shelves and hooks, and holy cow the closet is so nice. There's nothing on the floor and I can mostly find what I am looking for. It's not a huge thing but it feels huge to me
In this manic energy, I also hung up a spice rack in my pantry and it drastically improved quality of life there too
LeighofMar
Pitched a potential project to an investor who is very interested and we will talk again next week.
TheOriginalGenieSea
Fantastic! Congrats! My first apartment on my own, as well. I barely had furniture to fill it but I remember sitting on the stoop of my balcony and feeling such a sense of satisfaction.
Lucky-Guess8786
3h ago
Well done, OP. That is indeed proper adulting.
Wait till the time you buy your first new car. One with the new-car smell that is not artificially sprayed. It's a great feeling. Took me 50+ years to do it. I was so proud when I was handed the keys to my first brand new vehicle. Loved that wee girl. :)
View more comments
Create your account and connect with a world of communities.
Continue with Email
Continue With Phone Number
User Agreement
Privacy Policy
What’s something adults are “supposed” to do that just feels off to you?
r/Life
42 upvotes · 64 comments
Me with....literally anything anymore. I don't want to be the adult. Someone..please send help?!?!
r/Adulting
160 upvotes · 22 comments
Adult things
2K upvotes · 24 comments
456 upvotes · 282 comments
What being an adult feels like
2.3K upvotes · 21 comments
I love being an adult!
40 upvotes · 28 comments
What’s something that’s scares you as an adult?
237 upvotes · 156 comments
What’s something you started doing as an adult that made your life noticeably better?
r/AskMen
79 upvotes · 125 comments
Being an adult is fucking awesome
777 upvotes · 121 comments
What was a key moment that made you realize you were a “real” adult?
r/Productivitycafe
What makes you feel like an actual adult?
66 upvotes · 106 comments
When did you feel like an adult?
r/Millennials
54 upvotes · 109 comments
What's your life like as an adult?
r/AutismInWomen
45 upvotes · 35 comments
This sub is real negative about being an adult. I used to think like that too.
273 upvotes · 59 comments
I still don't "feel" like an adult despite doing adult things
36 upvotes · 52 comments
Is there a point in life where you actually start to feel like an adult?
r/AskUK
36 upvotes · 83 comments
What sad reality of being an adult that young people should know?
290 upvotes · 677 comments
When did you actually feel like an adult?
43 upvotes · 123 comments
Does anyone else feel like turning into an adult just feels kind of odd in general?
43 upvotes · 17 comments
What's an adult problem no one warned you about?
49 upvotes · 318 comments
Is it what adulting feels ?
r/GenZ
212 upvotes · 15 comments
DAE feel like you’re failing at being an adult?
r/AutisticAdults
44 upvotes · 22 comments
The more i grow up, the more i realize that "real adults" don't know what they're doing either
456 upvotes · 14 comments
A weird part of becoming an adult is realizing that every aspect of society has several hours of work put into it that seem totally unnecessary on the surface
854 upvotes · 88 comments
Public
Reddit Rules
Reddit, Inc. © 2025. All rights reserved. on the state it's: 



================================================
FILE: frontend/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



================================================
FILE: frontend/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: frontend/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: frontend/vite.config.ts
================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'


export default defineConfig({
  plugins: [react()],
  base: './',
  build: {
    outDir: "dist",
    assetsDir: "assets",
    rollupOptions: {
      output: {
        entryFileNames: "assets/[name]-[hash].js",
        chunkFileNames: "assets/[name]-[hash].js",
        assetFileNames: "assets/[name]-[hash].[ext]"
      }
    }
  },
  publicDir: "public",
})



================================================
FILE: frontend/public/auth-content-script.js
================================================
// Content script for the auth site to access localStorage
console.log('🔐 AUTH CONTENT: Script loaded on:', window.location.href);

// Listen for messages from the extension
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "getTokensFromLocalStorage") {
    console.log('🔍 AUTH CONTENT: Getting tokens from localStorage');
    
    const accessToken = localStorage.getItem('access_token');
    const refreshToken = localStorage.getItem('refresh_token');
    const session = localStorage.getItem('session');
    
    console.log('📋 AUTH CONTENT: Found tokens:', {
      hasAccessToken: !!accessToken,
      hasRefreshToken: !!refreshToken,
      hasSession: !!session,
      accessTokenLength: accessToken ? accessToken.length : 0,
      refreshTokenLength: refreshToken ? refreshToken.length : 0
    });
    
    if (accessToken) {
      sendResponse({
        accessToken: accessToken,
        refreshToken: refreshToken,
        session: session ? JSON.parse(session) : null
      });
    } else {
      sendResponse({ accessToken: null, refreshToken: null, session: null });
    }
    
    return true; // Keep the messaging channel open for async response
  }
});

// Check if tokens exist and notify background script for auth completion
function checkForAuthCompletion() {
  const accessToken = localStorage.getItem('access_token');
  const refreshToken = localStorage.getItem('refresh_token');
  
  if (accessToken && refreshToken) {
    console.log('✅ AUTH CONTENT: Auth tokens found, notifying background script');
    console.log(`   ├─ Access token length: ${accessToken.length}`);
    console.log(`   └─ Refresh token length: ${refreshToken.length}`);
    
    // Notify background script that auth is complete
    // Backend will handle cookie setting via login endpoint
    chrome.runtime.sendMessage({ action: "authCompleted" }).catch(error => {
      console.log('⚠️  AUTH CONTENT: Could not notify background script:', error);
    });
    
    return true; // Auth found
  }
  return false; // No auth found
}

// Monitor localStorage changes with enhanced detection
let lastAccessToken = localStorage.getItem('access_token');
let checkInterval;

function startTokenMonitoring() {
  console.log('👀 AUTH CONTENT: Starting token monitoring');
  
  // Check immediately
  if (checkForAuthCompletion()) {
    return; // Auth already complete
  }
  
  // Monitor with interval
  checkInterval = setInterval(() => {
    const currentAccessToken = localStorage.getItem('access_token');
    
    if (currentAccessToken && currentAccessToken !== lastAccessToken) {
      console.log('🔄 AUTH CONTENT: New token detected in localStorage');
      lastAccessToken = currentAccessToken;
      
      if (checkForAuthCompletion()) {
        // Stop monitoring once auth is complete
        clearInterval(checkInterval);
        console.log('🎉 AUTH CONTENT: Auth completion detected, stopping monitoring');
      }
    }
  }, 500); // Check every 500ms for faster detection
  
  // Stop monitoring after 60 seconds to prevent indefinite running
  setTimeout(() => {
    if (checkInterval) {
      clearInterval(checkInterval);
      console.log('⏰ AUTH CONTENT: Token monitoring timeout after 60 seconds');
    }
  }, 60000);
}

// Run on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', startTokenMonitoring);
} else {
  startTokenMonitoring();
}

// Also run after delays to catch auth that happens after page load
setTimeout(() => {
  if (!lastAccessToken) {
    console.log('🔍 AUTH CONTENT: Delayed check at 2 seconds');
    checkForAuthCompletion();
  }
}, 2000);

setTimeout(() => {
  if (!lastAccessToken) {
    console.log('🔍 AUTH CONTENT: Final delayed check at 5 seconds');
    checkForAuthCompletion();
  }
}, 5000);



================================================
FILE: frontend/public/background.js
================================================
// Configuration - will be replaced during build
// const BACKEND_URL = 'https://hippocampus-1.onrender.com';
const BACKEND_URL = 'http://localhost:8000';
const API_URL = '__VITE_API_URL__';

// BACKGROUND SCRIPT STARTUP LOGGING
console.log('🚀 BACKGROUND: Service worker starting up');
console.log(`   ├─ Startup time: ${new Date().toISOString()}`);
console.log(`   ├─ Extension ID: ${chrome.runtime.id}`);
console.log(`   ├─ Backend URL: ${BACKEND_URL}`);

// Check available commands at startup
chrome.commands.getAll((commands) => {
  console.log('⌨️ BACKGROUND: Available keyboard commands:');
  commands.forEach(command => {
    console.log(`   ├─ Command: ${command.name}`);
    console.log(`   │  ├─ Description: ${command.description}`);
    console.log(`   │  ├─ Shortcut: ${command.shortcut || 'Not set'}`);
    console.log(`   │  └─ Global: ${command.global || false}`);
  });
  
  if (commands.length === 0) {
    console.warn('⚠️ BACKGROUND: No keyboard commands found! Check manifest.json');
  }
});

// Test if action listener is properly set up
console.log('🔧 BACKGROUND: Setting up auth listener');

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "checkAuthStatus") {
    chrome.storage.local.get(['access_token', 'refresh_token'], (result) => {
      const { access_token, refresh_token } = result;
      if (!access_token || !refresh_token) {
        console.log('No valid tokens found, starting auth flow');
        startAuthFlow();
      } else {
        console.log('Valid tokens found');
      }
    });
  }
});

// Add runtime startup event listener
chrome.runtime.onStartup.addListener(() => {
  console.log('🔄 BACKGROUND: Extension runtime started');
});

chrome.runtime.onInstalled.addListener((details) => {
  console.log('📦 BACKGROUND: Extension installed/updated');
  console.log(`   ├─ Reason: ${details.reason}`);
  console.log(`   ├─ Previous version: ${details.previousVersion || 'N/A'}`);
  
  // Re-check commands after installation
  setTimeout(() => {
    chrome.commands.getAll((commands) => {
      console.log('🔍 BACKGROUND: Post-install command check:');
      commands.forEach(command => {
        console.log(`   ├─ ${command.name}: ${command.shortcut || 'Not set'}`);
      });
    });
  }, 1000);
});

// Helper function to notify frontend of authentication failures
async function notifyAuthenticationFailure(reason = 'Authentication failed') {
  console.log('🚫 BACKGROUND: Notifying frontend of authentication failure');
  try {
    // Get all extension tabs/windows
    const tabs = await chrome.tabs.query({});
    
    // Send message to all extension contexts
    for (const tab of tabs) {
      if (tab.url && tab.url.includes('chrome-extension://')) {
        try {
          await chrome.tabs.sendMessage(tab.id, { 
            action: "authenticationFailed", 
            reason: reason 
          });
          console.log(`   ├─ Notified tab ${tab.id} of auth failure`);
        } catch (error) {
          // Ignore errors if tab is not ready to receive messages
          console.log(`   ├─ Could not notify tab ${tab.id}: ${error.message}`);
        }
      }
    }
    
    console.log('✅ BACKGROUND: Authentication failure notifications sent');
  } catch (error) {
    console.error('❌ BACKGROUND: Failed to notify frontend of auth failure:', error);
  }
}

// Generic helper function for making API calls with auth failure detection
async function makeAuthenticatedRequest(url, options, actionName, maxRetries = 3) {
  let retryCount = 0;
  let lastStatusCode = null;
  
  while (retryCount < maxRetries) {
    try {
      const response = await fetch(url, {
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json'
        },
        ...options
      });
      
      lastStatusCode = response.status;
      
      if (response.ok) {
        console.log(`✅ BACKGROUND: ${actionName} successful`);
        return await response.json();
      } else if (response.status === 401 && retryCount < maxRetries - 1) {
        console.log(`⚠️  BACKGROUND: ${actionName} got 401, retry ${retryCount + 1}/${maxRetries}`);
        retryCount++;
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
        continue;
      } else {
        throw new Error(`${actionName} failed: ${response.status}`);
      }
    } catch (error) {
      if (retryCount < maxRetries - 1) {
        console.log(`⚠️  BACKGROUND: ${actionName} error, retry ${retryCount + 1}/${maxRetries}:`, error.message);
        retryCount++;
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
      } else {
        // Check if all retries failed due to authentication issues
        if (lastStatusCode === 401 || error.message.includes('401')) {
          console.log(`🚫 BACKGROUND: ${actionName} failed with authentication error after all retries`);
          notifyAuthenticationFailure(`${actionName} authentication failed after ${maxRetries} retries`);
        }
        throw new Error(`${actionName} failed after ${maxRetries} retries: ${error.message}`);
      }
    }
  }
}

// Multi-domain cookie cleanup function
async function clearAllAuthCookies() {
  console.log('🧹 BACKGROUND: Starting comprehensive cookie cleanup across all domains');
  
  // All domains where auth cookies might exist
  const domains = [
    'https://hippocampus-1.onrender.com',
    'https://extension-auth.vercel.app',
    'http://127.0.0.1:8000',
    'http://localhost:8000',
    BACKEND_URL
  ];
  
  // All possible auth cookie names
  const authCookieNames = [
    'access_token',
    'refresh_token',
    'user_id',
    'user_name',
    'user_picture'
  ];
  
  for (const domain of domains) {
    console.log(`   ├─ Clearing cookies from domain: ${domain}`);
    for (const cookieName of authCookieNames) {
      try {
        await chrome.cookies.remove({
          url: domain,
          name: cookieName
        });
        console.log(`   │  ✓ Cleared ${cookieName} from ${domain}`);
      } catch (error) {
        console.warn(`   │  ⚠️  Failed to clear ${cookieName} from ${domain}:`, error);
      }
    }
  }
  
  console.log('✅ BACKGROUND: Multi-domain cookie cleanup completed');
}

// Test that action listener is registered
console.log('📋 BACKGROUND: Registering chrome.action.onClicked listener...');

// STEP 1: Alt+M Extension Action Handler
// This fires when the user clicks the extension icon OR presses Alt+M
chrome.action.onClicked.addListener((tab) => {
  console.log('🔥 BACKGROUND STEP 1: Extension action triggered (Alt+M or icon click)');
  console.log(`   ├─ Tab ID: ${tab.id}`);
  console.log(`   ├─ Tab URL: ${tab.url}`);
  console.log(`   ├─ Current time: ${new Date().toISOString()}`);
  console.log('   ├─ This confirms the action listener is working!');
  
  console.log('🎨 BACKGROUND STEP 2: Injecting CSS styles into target tab');
  chrome.scripting.insertCSS({
    target: { tabId: tab.id },
    files: ["content.css"]
  }).then(() => {
    console.log('✅ BACKGROUND STEP 2: CSS injection completed successfully');
  }).catch((error) => {
    console.error('❌ BACKGROUND STEP 2: CSS injection failed:', error);
  });

  console.log('📜 BACKGROUND STEP 3: Executing content script in target tab');
  chrome.scripting.executeScript({
    target: { tabId: tab.id },
    files: ["content.js"]
  }).then(() => {
    console.log('✅ BACKGROUND STEP 3: Content script execution completed successfully');
    console.log('   ├─ The content script should now toggle the sidebar');
    console.log('   ├─ Check the tab console for content script logs');
  }).catch((error) => {
    console.error('❌ BACKGROUND STEP 3: Content script execution failed:', error);
  });
});

console.log('✅ BACKGROUND: chrome.action.onClicked listener registered successfully');

// MANUAL TEST: Add a context menu item to test if background script is working
chrome.runtime.onInstalled.addListener(() => {
  chrome.contextMenus.create({
    id: "test-background-script",
    title: "🧪 Test Background Script (Alt+M)",
    contexts: ["page"]
  });
});

// Handle context menu clicks (this tests if background script is responsive)
chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === "test-background-script") {
    console.log('🧪 BACKGROUND: Manual test triggered via context menu');
    console.log('   ├─ This confirms the background script is active and responsive');
    console.log('   ├─ Now manually executing the same logic as Alt+M shortcut');
    
    // Manually execute the same CSS injection and script execution as Alt+M
    console.log('🎨 BACKGROUND TEST: Injecting CSS styles into target tab');
    chrome.scripting.insertCSS({
      target: { tabId: tab.id },
      files: ["content.css"]
    }).then(() => {
      console.log('✅ BACKGROUND TEST: CSS injection completed successfully');
    }).catch((error) => {
      console.error('❌ BACKGROUND TEST: CSS injection failed:', error);
    });

    console.log('📜 BACKGROUND TEST: Executing content script in target tab');
    chrome.scripting.executeScript({
      target: { tabId: tab.id },
      files: ["content.js"]
    }).then(() => {
      console.log('✅ BACKGROUND TEST: Content script execution completed successfully');
    }).catch((error) => {
      console.error('❌ BACKGROUND TEST: Content script execution failed:', error);
    });
  }
});

// KEYBOARD SHORTCUT COMMAND HANDLER
chrome.commands.onCommand.addListener((command, tab) => {
  console.log('⌨️ BACKGROUND: Keyboard shortcut command received');
  console.log(`   ├─ Command: ${command}`);
  console.log(`   ├─ Tab ID: ${tab.id}`);
  console.log(`   ├─ Tab URL: ${tab.url}`);
  console.log(`   ├─ Current time: ${new Date().toISOString()}`);
  
  if (command === "quick_search") {
    console.log('🔍 BACKGROUND: Processing Alt+X (quick_search) command');
    
    // Alt+X: Open extension and focus on search
    console.log('🎨 BACKGROUND: Injecting CSS for Alt+X command');
    chrome.scripting.insertCSS({
      target: { tabId: tab.id },
      files: ["content.css"]
    }).then(() => {
      console.log('✅ BACKGROUND: CSS injection completed for Alt+X');
    }).catch((error) => {
      console.error('❌ BACKGROUND: CSS injection failed for Alt+X:', error);
    });

    console.log('📜 BACKGROUND: Executing content script for Alt+X command');
    chrome.scripting.executeScript({
      target: { tabId: tab.id },
      files: ["content.js"]
    }, () => {
      console.log('✅ BACKGROUND: Content script executed for Alt+X');
      console.log('⏱️ BACKGROUND: Setting up focus search message with 500ms delay');
      
      // Send message to focus on search after extension is loaded
      setTimeout(() => {
        console.log('📤 BACKGROUND: Sending focusSearch message to content script');
        chrome.tabs.sendMessage(tab.id, { 
          action: "focusSearch" 
        }).then(() => {
          console.log('✅ BACKGROUND: FocusSearch message sent successfully');
        }).catch((error) => {
          console.log("⚠️ BACKGROUND: Failed to send focusSearch message:", error);
          console.log('🔄 BACKGROUND: Trying alternative approach for already loaded scripts');
          
          // Try alternative approach for already loaded scripts
          chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: () => {
              console.log('🔄 CONTENT: Alternative focus approach executing');
              if (window.hippoCampusCreateSidebar) {
                console.log('✅ CONTENT: Found hippoCampusCreateSidebar function');
                const sidebar = window.hippoCampusCreateSidebar();
                if (sidebar) {
                  console.log('✅ CONTENT: Sidebar created successfully');
                  const iframe = sidebar.querySelector('iframe');
                  if (iframe) {
                    console.log('✅ CONTENT: Found iframe, sending focus message');
                    setTimeout(() => {
                      try {
                        iframe.contentWindow.postMessage({ action: "focusSearch" }, "*");
                        console.log('✅ CONTENT: Focus message sent to iframe');
                      } catch (err) {
                        console.error("❌ CONTENT: Failed to send focus message to iframe:", err);
                      }
                    }, 200);
                  } else {
                    console.warn('⚠️ CONTENT: No iframe found in sidebar');
                  }
                } else {
                  console.warn('⚠️ CONTENT: Failed to create sidebar');
                }
              } else {
                console.warn('⚠️ CONTENT: hippoCampusCreateSidebar function not available');
              }
            }
          });
        });
      }, 500);
    });
  } else {
    console.log(`⚠️ BACKGROUND: Unknown command received: ${command}`);
    console.log('   ├─ Expected commands: "quick_search" (Alt+X)');
    console.log('   ├─ Note: Alt+M should trigger chrome.action.onClicked, not commands');
  }
});






chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "searchAll") {
    // Make requests sequentially to avoid race conditions with token refresh
    async function fetchAllData() {
      try {
        console.log('🔍 BACKGROUND: Starting searchAll request');
        
        // Make both API calls in parallel using the new helper function
        console.log('🚀 BACKGROUND: Starting parallel fetch for links and notes');
        const [linksData, notesData] = await Promise.all([
          makeAuthenticatedRequest(`${BACKEND_URL}/links/get`, { method: 'GET' }, 'Links fetch'),
          makeAuthenticatedRequest(`${BACKEND_URL}/notes/`, { method: 'GET' }, 'Notes fetch')
        ]);
        
        console.log('📦 BACKGROUND: Links data received');
        console.log('📦 BACKGROUND: Notes data received');
        
        console.log('✅ BACKGROUND: SearchAll completed successfully');
        sendResponse({ success: true, links: linksData, notes: notesData });
      } catch (error) {
        console.error('❌ BACKGROUND: SearchAll error:', error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    fetchAllData();
    return true;
  }

  else if (message.action === "search") {
    async function performSearch() {
      try {
        console.log('🔍 BACKGROUND: Starting search request');
        
        const requestBody = {
          query: message.query
        };

        if (message.type !== "All") {
          requestBody.filter = { type: { $eq: message.type } };
        }

        const data = await makeAuthenticatedRequest(
          `${BACKEND_URL}/links/search`,
          {
            method: 'POST',
            body: JSON.stringify(requestBody)
          },
          'Search'
        );
        console.log("✅ BACKGROUND: Search response received:", data);
        sendResponse({ success: true, data });
      } catch (error) {
        console.error("❌ BACKGROUND: Search error:", error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performSearch();
    return true;
  }

  else if (message.action === "submit") {
    async function performSubmit() {
      try {
        console.log('📤 BACKGROUND: Starting submit request');
        
        const data = await makeAuthenticatedRequest(
          `${BACKEND_URL}/links/save`,
          {
            method: 'POST',
            body: JSON.stringify(message.data)
          },
          'Submit'
        );
        
        console.log("✅ BACKGROUND: Submit success:", data);
        sendResponse({ success: true, data });
      } catch (error) {
        console.error("❌ BACKGROUND: Submission error:", error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performSubmit();
    return true;
  }
  else if (message.action === "saveNotes") {
    async function performSaveNotes() {
      try {
        console.log('📝 BACKGROUND: Starting saveNotes request');
        
        let response;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            // Get tokens from chrome.storage.local
            const tokens = await chrome.storage.local.get(["access_token", "refresh_token"]);
            const headers = { 'Content-Type': 'application/json' };
            
            // Add Authorization header if token exists
            if (tokens.access_token) {
              headers['Authorization'] = `Bearer ${tokens.access_token}`;
              console.log('🔑 BACKGROUND: Added Authorization header to saveNotes request');
            } else {
              console.log('⚠️  BACKGROUND: No access token found in storage for saveNotes');
            }
            
            response = await fetch(`${BACKEND_URL}/notes/`, {
              method: 'POST',
              credentials: 'include',
              headers: headers,
              body: JSON.stringify(message.data)
            });
            
            console.log(`📝 BACKGROUND: SaveNotes response status: ${response.status}`);
            
            if (response.ok) {
              console.log('✅ BACKGROUND: SaveNotes successful');
              break; // Success, exit retry loop
            } else if (response.status === 401 && retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: SaveNotes got 401, retry ${retryCount + 1}/${maxRetries}`);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
              continue;
            } else {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
          } catch (error) {
            if (retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: SaveNotes error, retry ${retryCount + 1}/${maxRetries}:`, error.message);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            } else {
              throw error;
            }
          }
        }
        
        if (!response || !response.ok) {
          throw new Error(`SaveNotes failed after ${maxRetries} retries`);
        }
        
        const data = await response.json();
        console.log("✅ BACKGROUND: SaveNotes success:", data);
        sendResponse({ success: true, data });
      } catch (error) {
        console.error("❌ BACKGROUND: SaveNotes error:", error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performSaveNotes();
    return true;
  }

  else if (message.action === "getQuotes") {
    async function performGetQuotes() {
      try {
        console.log('💬 BACKGROUND: Starting getQuotes request');
        
        const data = await makeAuthenticatedRequest(
          `${BACKEND_URL}/quotes/`,
          { method: 'GET' },
          'GetQuotes'
        );
        
        console.log('✅ BACKGROUND: GetQuotes response received');
        sendResponse({ success: true, data });
      } catch (error) {
        console.error('❌ BACKGROUND: GetQuotes error:', error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performGetQuotes();
    return true;
  }
  
  else if (message.action === "delete") {
    async function performDelete() {
      try {
        console.log('🗑️ BACKGROUND: Starting delete request');
        
        let response;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            response = await fetch(`${BACKEND_URL}/links/delete?doc_id_pincone=${encodeURIComponent(message.query)}`, {
              method: 'DELETE',
              credentials: 'include'
            });
            
            if (response.ok) {
              console.log('✅ BACKGROUND: Delete successful');
              break; // Success, exit retry loop
            } else if (response.status === 401 && retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: Delete got 401, retry ${retryCount + 1}/${maxRetries}`);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
              continue;
            } else {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
          } catch (error) {
            if (retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: Delete error, retry ${retryCount + 1}/${maxRetries}:`, error.message);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            } else {
              throw error;
            }
          }
        }
        
        if (!response || !response.ok) {
          throw new Error(`Delete failed after ${maxRetries} retries`);
        }
        
        const data = await response.json();
        console.log('✅ BACKGROUND: Delete response received');
        sendResponse({ success: true, data });
      } catch (error) {
        console.error('❌ BACKGROUND: Delete error:', error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performDelete();
    return true;
  }
  
  else if (message.action === "deleteNote") {
    async function performDeleteNote() {
      try {
        console.log('🗑️ BACKGROUND: Starting deleteNote request');
        
        let response;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            response = await fetch(`${BACKEND_URL}/notes/${encodeURIComponent(message.query)}`, {
              method: 'DELETE',
              credentials: 'include'
            });
            
            if (response.ok) {
              console.log('✅ BACKGROUND: DeleteNote successful');
              break; // Success, exit retry loop
            } else if (response.status === 401 && retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: DeleteNote got 401, retry ${retryCount + 1}/${maxRetries}`);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
              continue;
            } else {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
          } catch (error) {
            if (retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: DeleteNote error, retry ${retryCount + 1}/${maxRetries}:`, error.message);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            } else {
              throw error;
            }
          }
        }
        
        if (!response || !response.ok) {
          throw new Error(`DeleteNote failed after ${maxRetries} retries`);
        }
        
        const data = await response.json();
        console.log('✅ BACKGROUND: DeleteNote response received');
        sendResponse({ success: true, data });
      } catch (error) {
        console.error('❌ BACKGROUND: DeleteNote error:', error);
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performDeleteNote();
    return true;
  }
  
  else if (message.action === "generateSummaryforContent") {
    async function performGenerateSummary() {
      try {
        console.log('📄 BACKGROUND: Starting generateSummary request');
        
        let response;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            // Get tokens from chrome.storage.local
            const tokens = await chrome.storage.local.get(["access_token", "refresh_token"]);
            const headers = { 'Content-Type': 'application/json' };
            
            // Add Authorization header if token exists
            if (tokens.access_token) {
              headers['Authorization'] = `Bearer ${tokens.access_token}`;
              console.log('🔑 BACKGROUND: Added Authorization header to request');
            } else {
              console.log('⚠️  BACKGROUND: No access token found in storage');
            }
            
            response = await fetch(`${BACKEND_URL}/summary/generate`, {
              method: 'POST',
              credentials: 'include',
              headers: headers,
              body: JSON.stringify({ content: message.content })
            });
            
            if (response.ok) {
              console.log('✅ BACKGROUND: GenerateSummary successful');
              break; // Success, exit retry loop
            } else if (response.status === 429) {
              // Rate limit exceeded - don't retry
              console.log('🚫 BACKGROUND: Genuine rate limit exceeded (HTTP 429)');
              console.log('   ├─ This is a legitimate rate limit from the backend API');
              throw new Error('RATE_LIMIT_EXCEEDED');
            } else if (response.status === 401 && retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: GenerateSummary got 401, retry ${retryCount + 1}/${maxRetries}`);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
              continue;
            } else {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
          } catch (error) {
            // Don't retry rate limit errors
            if (error.message === 'RATE_LIMIT_EXCEEDED') {
              throw error;
            }
            
            if (retryCount < maxRetries - 1) {
              console.log(`⚠️  BACKGROUND: GenerateSummary error, retry ${retryCount + 1}/${maxRetries}:`, error.message);
              retryCount++;
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            } else {
              throw error;
            }
          }
        }
        
        if (!response || !response.ok) {
          throw new Error(`GenerateSummary failed after ${maxRetries} retries`);
        }
        
        const data = await response.json();
        console.log('✅ BACKGROUND: GenerateSummary response received');
        sendResponse({ success: true, data });
      } catch (error) {
        console.error('❌ BACKGROUND: GenerateSummary error:', error);
        
        // Log specifically if this is a rate limit vs other error
        if (error.message === 'RATE_LIMIT_EXCEEDED') {
          console.log('📊 BACKGROUND: Confirmed rate limit error being sent to content script');
        } else {
          console.log('📊 BACKGROUND: Non-rate-limit error being sent to content script:', error.message);
        }
        
        sendResponse({ success: false, error: error.message });
      }
    }
    
    performGenerateSummary();
    return true;
  }

  else if (message.action === "authCompleted") {
    // Notify all extension windows that auth has completed
    chrome.tabs.query({}, (tabs) => {
      tabs.forEach(tab => {
        if (tab.url && tab.url.includes('chrome-extension://')) {
          chrome.tabs.sendMessage(tab.id, { action: "authStateChanged" }).catch(() => {
            // Ignore errors if extension popup is not active
          });
        }
      });
    });
    sendResponse({ success: true });
    return true;
  }

  else if (message.action === "clearAllCookies") {
    // Handle request to clear all auth cookies
    clearAllAuthCookies()
      .then(() => {
        sendResponse({ success: true, message: "All auth cookies cleared" });
      })
      .catch((error) => {
        console.error('Background cookie cleanup failed:', error);
        sendResponse({ success: false, error: error.message });
      });
    return true;
  }

  else {
    null
  }

});

// Enhanced cookie monitoring for authentication across all domains
chrome.cookies.onChanged.addListener((changeInfo) => {
  // Monitor the correct backend domain instead of API_URL
  const backendDomain = new URL(BACKEND_URL).hostname;
  
  if (changeInfo.cookie.domain === backendDomain &&
      (changeInfo.cookie.name === 'access_token' || changeInfo.cookie.name === 'refresh_token')) {
    
    if (!changeInfo.removed) {
      console.log(`🔑 BACKGROUND: Auth cookie detected on ${backendDomain}:`, changeInfo.cookie.name);
      console.log('   ├─ Triggering auth check across extension');
      
      // Notify extension about potential auth completion
      chrome.tabs.query({}, (tabs) => {
        tabs.forEach(tab => {
          if (tab.url && tab.url.includes('chrome-extension://')) {
            chrome.tabs.sendMessage(tab.id, { action: "checkAuthStatus" }).catch(() => {
              // Ignore errors if extension popup is not active
            });
          }
        });
      });
    } else {
      console.log(`🚫 BACKGROUND: Auth cookie removed from ${backendDomain}:`, changeInfo.cookie.name);
      console.log('   ├─ This may indicate logout or session expiration');
    }
  }
});


================================================
FILE: frontend/public/content.css
================================================
#my-extension-sidebar {
  position: fixed;
  top: 50%;
  right: 20px;
  width: 420px;
  height: 500px;
  border-radius: 8px;
  background: transparent !important;
  z-index: 99999999;
  transition: transform 0.3s ease-in-out;
  border-left: transparent !important;
  overflow: hidden !important;
  /* Start hidden (off-screen to the right) */
  transform: translateY(-50%) translateX(100%);
}

@keyframes slideIn {
  from {
    transform: translateY(-50%) translateX(100%);
  }
  to {
    transform: translateY(-50%) translateX(0);
  }
}

@keyframes slideOut {
  from {
    transform: translateY(-50%) translateX(0);
  }
  to {
    transform: translateY(-50%) translateX(100%);
  }
}





================================================
FILE: frontend/public/content.js
================================================
// STEP 0: Handle multiple script execution
console.log('🔄 CONTENT STEP 0: Content script execution started');
console.log(`   ├─ Execution time: ${new Date().toISOString()}`);
console.log(`   ├─ Current URL: ${window.location.href}`);
console.log(`   ├─ Document ready state: ${document.readyState}`);

if (window.hippoCampusContentScriptLoaded) {
  console.log("♻️ CONTENT STEP 0: HippoCampus content script already loaded, executing toggle only");
  console.log("   ├─ This is a re-execution of the content script (not first load)");
  
  // Simple toggle logic - always check DOM first, ignore state inconsistencies
  const existingSidebar = document.getElementById("my-extension-sidebar");
  console.log('🔍 CONTENT STEP 0: Simple toggle - checking DOM for existing sidebar');
  console.log(`   ├─ existingSidebar found: ${!!existingSidebar}`);
  
  if (existingSidebar) {
    // Sidebar exists in DOM - close it
    console.log("📴 CONTENT STEP 0: Sidebar exists - closing it");
    if (window.hippoCampusCloseSidebar) {
      console.log("   ├─ Using global hippoCampusCloseSidebar function");
      window.hippoCampusCloseSidebar(existingSidebar);
    } else {
      console.log("⚠️ CONTENT STEP 0: Global close function not available, using fallback");
      existingSidebar.style.animation = "slideOut 0.3s ease-in-out forwards";
      setTimeout(() => {
        if (existingSidebar.parentNode) {
          existingSidebar.remove();
        }
        document.removeEventListener("click", window.hippoCampusHandleClickOutside);
      }, 300);
    }
  } else {
    // No sidebar in DOM - create it
    console.log("📱 CONTENT STEP 0: No sidebar exists - creating new one");
    if (window.hippoCampusCreateSidebar) {
      console.log("   ├─ Using global hippoCampusCreateSidebar function");
      window.hippoCampusCreateSidebar();
    } else {
      console.log("⚠️ CONTENT STEP 0: Global create function not available");
    }
  }
} else {
  console.log("🆕 CONTENT STEP 0: First-time content script execution");
  window.hippoCampusContentScriptLoaded = true;
  console.log("   ├─ Set hippoCampusContentScriptLoaded flag to prevent re-initialization");

if (window.location.protocol === "chrome:") {
  window.location.href = chrome.runtime.getURL("error.html");
}

// Flag to prevent duplicate summary generation requests
let isGeneratingSummary = false;

// Global state tracking
let extensionState = window.hippoCampusExtensionState || {
  isOpen: false,
  isInitializing: false
};

// Make state globally available
window.hippoCampusExtensionState = extensionState;

// Sync state with DOM on script load
const existingSidebarOnLoad = document.getElementById("my-extension-sidebar");
if (existingSidebarOnLoad && !extensionState.isOpen) {
  console.log("Found existing sidebar, syncing state");
  extensionState.isOpen = true;
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "closeExtension" && message.target === "content") {
    const sidebar = document.getElementById("my-extension-sidebar");
    if (sidebar) {
      sidebar.style.animation = "slideOut 0.3s ease-in-out forwards";
      setTimeout(() => {
        sidebar.remove();
        // Clean up click listener
        document.removeEventListener("click", window.hippoCampusHandleClickOutside || handleClickOutside);
      }, 300);
    }
    sendResponse({success: true});
  }
  
  if (message.action === "focusSearch") {
    // Alt+X handler: ensure extension is open and focus on search
    let sidebar = document.getElementById("my-extension-sidebar");
    
    if (!sidebar || !extensionState.isOpen) {
      // If sidebar doesn't exist, create it first
      sidebar = createSidebar();
      if (!sidebar) {
        console.log("Failed to create sidebar for focus search");
        sendResponse({success: false, error: "Failed to create sidebar"});
        return;
      }
    }
    
    // Send message to iframe to focus on search input
    if (sidebar) {
      const iframe = sidebar.querySelector('iframe');
      if (iframe) {
        // Wait for iframe to load before sending message
        setTimeout(() => {
          try {
            iframe.contentWindow.postMessage({ action: "focusSearch" }, "*");
            console.log("Focus search message sent to iframe");
          } catch (error) {
            console.error("Failed to send focus message to iframe:", error);
          }
        }, 200); // Increased delay to ensure iframe is loaded
      }
    }
    
    sendResponse({success: true});
  }
  if (message.action === "extractPageContent") {
    // Prevent duplicate summary generation
    if (isGeneratingSummary) {
      console.log("Summary generation already in progress, ignoring duplicate request");
      sendResponse({ error: "Summary generation already in progress" });
      return;
    }
    
    isGeneratingSummary = true;
    
    const elements = Array.from(document.querySelectorAll('div, p, a'));
    const seen = new Set();
    let lines = elements
      .filter(el => !el.querySelector('div, p, a'))
      .filter(el => {
        const style = window.getComputedStyle(el);
        return (
          el.offsetParent !== null &&
          style.display !== "none" &&
          style.visibility !== "hidden"
        );
      })
      .map(el => el.textContent?.replace(/\s+/g, ' ').trim() || '')
      .filter(text => text.length > 2 && !seen.has(text) && seen.add(text)); 

    let content = lines.join('\n').replace(/\n{2,}/g, '\n');
    
    // Send message to extension frontend to handle API call
    const sidebar = document.getElementById("my-extension-sidebar");
    if (sidebar) {
      const iframe = sidebar.querySelector('iframe');
      if (iframe) {
        // Create a promise to handle the response
        const messageId = Date.now() + Math.random();
        const responseHandler = (event) => {
          if (event.data && event.data.messageId === messageId) {
            window.removeEventListener('message', responseHandler);
            isGeneratingSummary = false;
            
            if (event.data.success) {
              console.log("Content summarized successfully");
              console.log("Summary:", event.data.data);
              sendResponse({ content: event.data.data });
            } else {
              const errorMessage = event.data.error || "Failed to generate summary";
              
              // Handle rate limit error specifically
              if (errorMessage === 'RATE_LIMIT_EXCEEDED') {
                console.log("🚫 CONTENT: Rate limit exceeded for summary generation");
                console.log("   ├─ This is a legitimate daily limit reached");
                sendResponse({ 
                  error: 'RATE_LIMIT_EXCEEDED'
                });
              } else {
                console.error("❌ CONTENT: Failed to generate summary:", errorMessage);
                sendResponse({ error: errorMessage });
              }
            }
          }
        };
        
        window.addEventListener('message', responseHandler);
        
        // Send message to iframe
        iframe.contentWindow.postMessage({ 
          action: "generateSummary", 
          content: content,
          messageId: messageId
        }, "*");
      } else {
        isGeneratingSummary = false;
        sendResponse({ error: "Extension iframe not found" });
      }
    } else {
      isGeneratingSummary = false;
      sendResponse({ error: "Extension not open" });
    }
    return true;
  }
});
  

// Global click handler for closing sidebar when clicking outside
const handleClickOutside = (event) => {
  const sidebar = document.getElementById("my-extension-sidebar");
  if (sidebar && !sidebar.contains(event.target)) {
    closeSidebar(sidebar);
  }
};

// Make globally available
window.hippoCampusHandleClickOutside = handleClickOutside;

// STEP 5A: Function to close sidebar with animation
const closeSidebar = (sidebarElement) => {
  console.log('🔻 CONTENT STEP 5A: closeSidebar function called');
  console.log(`   ├─ Sidebar element provided: ${!!sidebarElement}`);
  
  if (sidebarElement) {
    console.log('✅ CONTENT STEP 5A: Valid sidebar element found, proceeding with closure');
    console.log(`   ├─ Sidebar element ID: ${sidebarElement.id}`);
    console.log(`   ├─ Sidebar current display: ${window.getComputedStyle(sidebarElement).display}`);
    console.log(`   ├─ Sidebar current visibility: ${window.getComputedStyle(sidebarElement).visibility}`);
    
    console.log('📊 CONTENT STEP 5A: Updating extension state to closed');
    extensionState.isOpen = false;
    console.log(`   ├─ extensionState.isOpen set to: ${extensionState.isOpen}`);
    
    console.log('🎬 CONTENT STEP 5A: Applying slideOut animation');
    sidebarElement.style.animation = "slideOut 0.3s ease-in-out forwards";
    console.log('   ├─ Animation applied: slideOut 0.3s ease-in-out forwards');
    
    console.log('⏱️ CONTENT STEP 5A: Setting up cleanup timeout (300ms)');
    setTimeout(() => {
      console.log('🧹 CONTENT STEP 5A: Cleanup timeout executing');
      
      if (sidebarElement.parentNode) {
        console.log('✅ CONTENT STEP 5A: Removing sidebar from DOM');
        console.log(`   ├─ Parent node: ${sidebarElement.parentNode.tagName}`);
        sidebarElement.remove();
        console.log('   ├─ Sidebar element removed successfully');
      } else {
        console.log('⚠️ CONTENT STEP 5A: Sidebar already removed from DOM');
      }
      
      // Remove click listener when sidebar is closed
      console.log('🔇 CONTENT STEP 5A: Removing click outside listener');
      document.removeEventListener("click", window.hippoCampusHandleClickOutside || handleClickOutside);
      console.log('   ├─ Click outside listener removed');
      
      console.log('🏁 CONTENT STEP 5A: Resetting initialization state');
      extensionState.isInitializing = false;
      console.log(`   ├─ extensionState.isInitializing set to: ${extensionState.isInitializing}`);
      
      console.log('✅ CONTENT STEP 5A: Sidebar closure completed successfully');
    }, 300);
  } else {
    console.log('❌ CONTENT STEP 5A: No sidebar element provided, cannot close');
  }
};

// Make function globally available
window.hippoCampusCloseSidebar = closeSidebar;

// STEP 5B: Function to create sidebar
const createSidebar = () => {
  console.log('🔺 CONTENT STEP 5B: createSidebar function called');
  console.log(`   ├─ Function call time: ${new Date().toISOString()}`);
  console.log(`   ├─ Current URL: ${window.location.href}`);
  
  // Prevent multiple sidebar creation
  console.log('🚧 CONTENT STEP 5B: Checking for concurrent initialization');
  if (extensionState.isInitializing) {
    console.log("⚠️ CONTENT STEP 5B: Sidebar creation already in progress, ignoring");
    console.log("   ├─ This prevents multiple sidebars from being created simultaneously");
    return null;
  }
  
  // Check if sidebar already exists
  console.log('🔍 CONTENT STEP 5B: Checking for existing sidebar in DOM');
  const existingSidebar = document.getElementById("my-extension-sidebar");
  if (existingSidebar) {
    console.log("⚠️ CONTENT STEP 5B: Sidebar already exists, not creating new one");
    console.log(`   ├─ Existing sidebar ID: ${existingSidebar.id}`);
    console.log(`   ├─ Existing sidebar display: ${window.getComputedStyle(existingSidebar).display}`);
    return existingSidebar;
  }
  
  console.log("🚀 CONTENT STEP 5B: Creating new sidebar");
  console.log('🔒 CONTENT STEP 5B: Setting initialization lock');
  extensionState.isInitializing = true;
  console.log(`   ├─ extensionState.isInitializing set to: ${extensionState.isInitializing}`);
  
  console.log('🏗️ CONTENT STEP 5B: Creating sidebar container element');
  const sidebar = document.createElement("div");
  sidebar.id = "my-extension-sidebar";
  console.log(`   ├─ Sidebar element created with ID: ${sidebar.id}`);
  
  console.log('🎬 CONTENT STEP 5B: Applying slideIn animation');
  sidebar.style.animation = "slideIn 0.3s ease-in-out forwards";
  console.log('   ├─ Animation applied: slideIn 0.3s ease-in-out forwards');

  console.log('🖼️ CONTENT STEP 5B: Creating iframe element');
  const iframe = document.createElement("iframe");
  const iframeSrc = chrome.runtime.getURL("index.html");
  iframe.src = iframeSrc;
  console.log(`   ├─ Iframe source URL: ${iframeSrc}`);
  
  console.log('📏 CONTENT STEP 5B: Setting iframe styles');
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.style.border = "none";
  console.log('   ├─ Iframe styles applied (width: 100%, height: 100%, border: none)');
  
  console.log('🔗 CONTENT STEP 5B: Appending iframe to sidebar');
  sidebar.appendChild(iframe);
  console.log('   ├─ Iframe successfully appended to sidebar');
  
  console.log('📍 CONTENT STEP 5B: Appending sidebar to document body');
  document.body.appendChild(sidebar);
  console.log('   ├─ Sidebar successfully appended to document body');

  // Update state
  console.log('📊 CONTENT STEP 5B: Updating extension state');
  extensionState.isOpen = true;
  extensionState.isInitializing = false;
  console.log(`   ├─ extensionState.isOpen set to: ${extensionState.isOpen}`);
  console.log(`   ├─ extensionState.isInitializing set to: ${extensionState.isInitializing}`);

  // Add click outside listener with small delay to avoid immediate closing
  console.log('👂 CONTENT STEP 5B: Setting up click outside listener (100ms delay)');
  setTimeout(() => {
    console.log('🎧 CONTENT STEP 5B: Adding click outside event listener');
    document.addEventListener("click", window.hippoCampusHandleClickOutside || handleClickOutside);
    console.log('   ├─ Click outside listener added successfully');
  }, 100);
  
  console.log('✅ CONTENT STEP 5B: Sidebar creation completed successfully');
  console.log(`   ├─ Sidebar element: ${sidebar.tagName}#${sidebar.id}`);
  console.log(`   ├─ Sidebar in DOM: ${document.body.contains(sidebar)}`);
  
  return sidebar;
};

// Make function globally available
window.hippoCampusCreateSidebar = createSidebar;

// STEP 4: Main toggle function (called when Alt+M is pressed)
(() => {
  console.log('🚀 CONTENT STEP 4: Main toggle function executing');
  console.log(`   ├─ Script execution time: ${new Date().toISOString()}`);
  console.log(`   ├─ Current URL: ${window.location.href}`);
  console.log(`   ├─ Document ready state: ${document.readyState}`);
  
  // Simple DOM-based toggle - ignore state inconsistencies
  const existingSidebar = document.getElementById("my-extension-sidebar");
  console.log('🔍 CONTENT STEP 4: Simple toggle - checking DOM for existing sidebar');
  console.log(`   ├─ Existing sidebar found: ${!!existingSidebar}`);
  
  if (existingSidebar) {
    // Sidebar exists in DOM - close it
    console.log('📴 CONTENT STEP 4: Sidebar exists - closing it');
    console.log('   ├─ Calling closeSidebar function');
    closeSidebar(existingSidebar);
  } else {
    // No sidebar in DOM - create it
    console.log('📱 CONTENT STEP 4: No sidebar exists - creating new one');
    console.log('   ├─ Calling createSidebar function');
    createSidebar();
  }
})();

} // Close the else block for script loading check


================================================
FILE: frontend/public/error.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extension Blocked</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background-color: #f8d7da;
            color: #721c24;
        }
        .container {
            max-width: 500px;
            margin: auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚠️ Extension Cannot Run Here</h1>
        <p>Chrome does not allow extensions to run on <code>chrome://</code> pages.</p>
        <p>Try using the extension on a normal website.</p>
    </div>
</body>
</html>


================================================
FILE: frontend/public/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
    <script type="module" crossorigin src="/assets/index-B5tmHCMt.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-D-I1wktH.css">
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>



================================================
FILE: frontend/public/manifest.json
================================================
{
  "manifest_version": 3,
  "name": "HippoCampus",
  "version": "1.0",
  "description": "I can remember anything for you",
  "icons": {
    "256": "HippoCampusLogo.png"
  },
  "permissions": [
    "scripting", 
    "activeTab",
    "tabs",
    "bookmarks",
    "cookies",
    "storage",
    "contextMenus",
    "identity"
  ],
  "host_permissions": [
    "http://localhost:5173/*",
    "https://magical-famous-emu.ngrok-free.app/*",
    "https://hippocampus-1.onrender.com//*",
    "http://127.0.0.1:8000/*",
    "<all_urls>"
  ],
  "web_accessible_resources": [
    {
      "resources": ["index.html","error.html"],
      "matches": ["<all_urls>"]
    }
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_title": "Toggle Sidebar"
  },
  "commands": {
    "_execute_action": {
      "suggested_key": {
        "default": "Alt+M",
        "mac": "Alt+M"
      },
      "description": "Toggle HippoCampus extension"
    },
    "quick_search": {
      "suggested_key": {
        "default": "Alt+X",
        "mac": "Alt+X"
      },
      "description": "Quick search in HippoCampus"
    }
  },
  "key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtTCQJG9ku8pF8htahg1yJCESWF7/fiZNpSC/K9bJ5AW742n4z80oMP8+tbGAYNKjx0zJtXJL1sKnTM7Wa3JQLgnuGe4BYM8ySg+pCtgdWT3ZW6ScIec0KNKEfr/DLPSkxwx20LBYzJFSXOlYyzUXn5h2lKZ9voHx8+z5/F2CXXtgeENjFA4QSejQJJ9JgseTPDsdYhO6GyHJtW6qKXmBwuhv6/IqwDZupb2tLIiSC/kYVtKpbbej9Rg9cJiJx//UrJtyHC9nppOCFhChG50p+0HnKhW++8CCUiDmfRdfVvfffl1f+1FbCziTchRO3oUzHAPF6XjBxk9tO4GhDyc3MwIDAQAB"
}



================================================
FILE: frontend/scripts/replace-env-vars.mjs
================================================
#!/usr/bin/env node

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { config } from 'dotenv';
import path from 'path';

// Load environment variables
config();

const BACKEND_URL = process.env.VITE_BACKEND_URL;
const API_URL = process.env.VITE_API_URL;

console.log('Replacing environment variables in public files...');
console.log('BACKEND_URL:', BACKEND_URL);
console.log('API_URL:', API_URL);

// Update background.js
const backgroundPath = path.join(process.cwd(), 'dist', 'background.js');
if (existsSync(backgroundPath)) {
  let backgroundContent = readFileSync(backgroundPath, 'utf8');
  
  // Replace the BACKEND_URL constant
  backgroundContent = backgroundContent.replace(
    /const BACKEND_URL = '[^']*';/,
    `const BACKEND_URL = '${BACKEND_URL}';`
  );
  
  // Replace the API_URL constant
  backgroundContent = backgroundContent.replace(
    /const API_URL = '[^']*';/,
    `const API_URL = '${API_URL}';`
  );
  
  // Replace placeholder with actual backend URL
  backgroundContent = backgroundContent.replace(
    /__VITE_BACKEND_URL__/g,
    BACKEND_URL
  );
  
  // Replace placeholder with actual API URL
  backgroundContent = backgroundContent.replace(
    /__VITE_API_URL__/g,
    API_URL
  );
  
  writeFileSync(backgroundPath, backgroundContent);
  console.log('✓ Updated background.js with all environment variables');
}

// Update manifest.json
const manifestPath = path.join(process.cwd(), 'dist', 'manifest.json');
if (existsSync(manifestPath)) {
  let manifestContent = readFileSync(manifestPath, 'utf8');
  const manifest = JSON.parse(manifestContent);
  
  // Update host permissions to use actual backend URL
  manifest.host_permissions = manifest.host_permissions.map(permission => {
    if (permission.includes('hippocampus-1.onrender.com')) {
      return `${new URL(BACKEND_URL).origin}/*`;
    }
    return permission;
  });
  
  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
  console.log('✓ Updated manifest.json');
}

console.log('Environment variable replacement completed!');



================================================
FILE: frontend/src/App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


@keyframes gradientShift {
          0%, 100% {
            background-position: 0% 50%;
          }
          50% {
            background-position: 100% 50%;
          }
}



================================================
FILE: frontend/src/App.tsx
================================================
import { HashRouter as Router, Routes, Route, useLocation, useNavigate } from "react-router-dom";
import { AnimatePresence, motion } from "framer-motion";
import SearchPage from "./page/SearchPage";
import Intro from "./page/IntroPage";
import SearchResponse from "./page/SearchResultPage";
import ResponsePage from "./page/ResponsePage";
import SummarizePage from "./page/SummarizePage";
import './index.css';



const pageVariants = {
  initial: { opacity: 1, y: 0 },
  animate: { opacity: 1, y: 0, transition: { duration: 0.2 } },
  exit: { opacity: 1, y: 0, transition: { duration: 0.2 } }
};

import { ReactNode, useEffect, useState } from "react";
import { useSimpleAuth } from "./components/SimpleAuth";
import AuthLoadingIndicator from "./components/AuthLoadingIndicator";
import { getQuotes, generateSummary } from "./utils/apiClient";

// Extend Window interface to include our custom property
declare global {
  interface Window {
    authTransferInProgress?: boolean;
  }
}

const PageWrapper = ({ children }: { children: ReactNode }) => (
  <motion.div
    initial="initial"
    animate="animate"
    exit="exit"
    variants={pageVariants}
    className="p-0 bg-transparent min-w-[100%]"
  >
    {children}
  </motion.div>
);

const AnimatedRoutes = () => {
  const Navigate = useNavigate();
  const location = useLocation();
  const [quotes, setQuotes] = useState<string[]>([]);
const { loading: isLoading, isAuthenticated } = useSimpleAuth();

  // Keyboard shortcut handler for Alt+X (when extension is already open)
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Check for Alt+X combination
      if (event.altKey && event.key.toLowerCase() === 'x') {
        event.preventDefault(); // Prevent default browser action for Alt+X
        console.log('🔍 APP: Alt+X shortcut triggered, navigating to search page');
        
        // Navigate to search page (extension is already open)
        Navigate("/search");
      }
    };

    // Message listener for focus requests and generateSummary requests from content script
    const handleMessage = (event: MessageEvent) => {
      if (event.data && event.data.action === "focusSearch") {
        console.log('🔍 APP: Focus search message received from content script');
        Navigate("/search");
      }
      
      if (event.data && event.data.action === "generateSummary") {
        const { content, messageId } = event.data;
        console.log('📝 APP: Generate summary request received');
        
        generateSummary(content)
          .then(data => {
            console.log("Summary generated successfully:", data);
            if (event.source) {
              event.source.postMessage({ success: true, data, messageId }, { targetOrigin: "*" });
            }
          })
          .catch(error => {
            console.error("Failed to generate summary:", error);
            if (event.source) {
              event.source.postMessage({ success: false, error: error.message, messageId }, { targetOrigin: "*" });
            }
          })
      }
    };

    // Add event listeners
    document.addEventListener('keydown', handleKeyDown);
    window.addEventListener('message', handleMessage);

    // Cleanup function to remove event listeners
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('message', handleMessage);
    };
  }, [Navigate]);


  // Simplified auth checking - let useAuth hook handle everything
  // The useAuth hook already implements the proper OAuth flow from OauthImplementation.md

  

  useEffect(() => {
    const handleAuthFlow = async () => {

      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

      if (!tab?.url) return;



      try {
        // Check if user is authenticated via backend cookies and validate them
        const cookie = await chrome.cookies.get({
          url: import.meta.env.VITE_BACKEND_URL,
          name: 'access_token',
        });

        if (cookie && location.pathname === "/") {
          console.log('🔍 APP: Backend cookies found in handleAuthFlow - useAuth will handle validation');
          // Let useAuth hook handle validation to avoid duplicate calls
        }

        // Load quotes from localStorage or fetch from backend
        if(localStorage.getItem("quotes")){
          console.log("found Quotes")
          setQuotes(JSON.parse(localStorage.getItem("quotes") || "[]"));
          console.log("have set the quotes")
        }else{
          const fetchQuotes = async (retryCount = 0) => {
            try {
              const quotesData = await getQuotes();
              if (quotesData && Array.isArray(quotesData)) {
                const filteredQuotes = quotesData.filter((quote: string) => quote.length > 0);
                setQuotes(prev => [
                  ...new Set([...prev, ...filteredQuotes])
                ]);
                console.log("GOT QUOTES FROM BACKEND")
                localStorage.setItem("quotes", JSON.stringify(filteredQuotes));
                console.log("Quotes are set")
              } else {
                console.error("Response data is not an array:", quotesData);
              }
            } catch (error: any) {
              console.error("Failed to get quotes:", error?.message || "No response");
              // Retry up to 2 times with increasing delay for new users
              if (retryCount < 2) {
                console.log(`Retrying quotes fetch in ${(retryCount + 1) * 1000}ms...`);
                setTimeout(() => fetchQuotes(retryCount + 1), (retryCount + 1) * 1000);
              }
            }
          };
          
          fetchQuotes();
        }
      } catch (error) {
        console.error("Error handling auth flow:", error);
      }


      
      
    };

    handleAuthFlow();

    // Enhanced cookie change monitoring for session management
    const handleCookieChange = (changeInfo: chrome.cookies.CookieChangeInfo) => {
      if (changeInfo.cookie.name === "access_token" && 
          changeInfo.cookie.domain.includes(new URL(import.meta.env.VITE_BACKEND_URL).hostname)) {
        
        if (changeInfo.removed) {
          console.log('🚫 APP: Backend access token was removed, checking if we need to redirect to auth');
          
          // Check if we're on a protected page and should redirect to intro/auth
          if (location.pathname === "/submit" || location.pathname === "/search" || location.pathname === "/response") {
            console.log('🔄 APP: User was on protected page, redirecting to intro for re-authentication');
            Navigate("/");
          }
        } else {
          console.log('🔑 APP: Backend access token detected, user may have authenticated');
          // Token was added, but don't auto-navigate - let existing auth flow handle it
        }
      }
    };

    // Listen for background script auth failure notifications
    const handleBackgroundMessage = (message: any, _sender: any, sendResponse: any) => {
      if (message.action === "authenticationFailed") {
        console.log('🚫 APP: Received authentication failure notification from background script');
        console.log('🔄 APP: Redirecting to intro page for re-authentication');
        Navigate("/");
        sendResponse({ received: true });
      }
    };

    chrome.cookies.onChanged.addListener(handleCookieChange);
    chrome.runtime.onMessage.addListener(handleBackgroundMessage);
    
    return () => {
      chrome.cookies.onChanged.removeListener(handleCookieChange);
      chrome.runtime.onMessage.removeListener(handleBackgroundMessage);
    };
  }, []);

  // Navigation effect based on auth state
  useEffect(() => {
    if (!isLoading && isAuthenticated && location.pathname === "/") {
      console.log('🎯 APP: User is authenticated, redirecting to submit page');
      Navigate("/submit");
    }
  }, [isLoading, isAuthenticated, location.pathname, Navigate]);

  // Show loading screen immediately when auth is being checked
  if (isLoading) {
    return (
      <AuthLoadingIndicator 
        message="Hold on" 
        showDetails={true}
      />
    );
  }

  return (
    <AnimatePresence mode="wait">
      <Routes location={location} key={location.pathname}>
        <Route path="/" element={<PageWrapper><Intro /></PageWrapper>} />
        <Route path="/submit" element={<PageWrapper><ResponsePage /></PageWrapper>} />
        <Route path="/search" element={<PageWrapper><SearchPage Quote={quotes[Math.floor(Math.random() * quotes.length)]} /></PageWrapper>} />
        <Route path="/response" element={<PageWrapper><SearchResponse /></PageWrapper>} />
        <Route path="/summarize" element={<PageWrapper><SummarizePage /></PageWrapper>} />
      </Routes>
    </AnimatePresence>
  );
};

const App = () => {
  // Detect if we're running in popup mode
  const isPopup = window.location.search.includes('popup=true') || 
                  window.innerWidth <= 420 && window.innerHeight <= 600;

  return (
    <Router>
      <div className={`flex items-center justify-center bg-transparent ${
        isPopup ? 'min-h-[500px] w-[419px]' : ''
      }`}>
        <AnimatedRoutes />
      </div>
    </Router>
  );
};

export default App;


================================================
FILE: frontend/src/index.css
================================================
@import url('https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:wght@100..900&display=swap');
@import url('https://fonts.cdnfonts.com/css/georgia');
@import url('https://fonts.cdnfonts.com/css/vollkorn');
@import url('https://fonts.googleapis.com/css2?family=Gilda+Display&family=Oswald:wght@200..700&display=swap');
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom text truncation utilities */
@layer utilities {
  .line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
  
  .line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }
  
  .line-clamp-3 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
  }
  
  .text-truncate {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Hide scrollbar but keep functionality */
  .scrollbar-hide {
    /* For Webkit browsers */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer and Edge */
  }
  
  .scrollbar-hide::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
  }

  .py-11 {
    padding-top: 4rem;
    padding-bottom: 2.5rem;
  }

  .py-10 {
    padding-top: 3.5rem;
    padding-bottom: 2.5rem;
  }

  .py-12 {
    padding-top: 2.5rem;
    padding-bottom: 2rem;
  }

}

:root {
  --primary-red: #ff4c4c;
  --primary-blue: #76ADFF;
  --primary-green: #DAEF68;
  --primary-yellow:  #FFCE00;
  --primary-orange: #FF8E59;
  --primary-white: #FFFFFF;
  --soft-blue: #A3C8FF;
  --deep-blue: #4A90E2;
  --light-green: #B4E4A3;
  --dark-green: #4C9C31;
  --warm-yellow: #F7D700;
  --light-orange: #FFB380;
  --dark-orange: #F07A35;
  --soft-pink: #F8B6D3;
  --bright-purple: #9B59B6;
  --muted-teal: #4FB5B5;
  --light-gray: #E1E1E1;
  --dark-gray: #707070;
  --rich-burgundy: #a71d1d;
  --earthy-brown: #8D6E63;
  --pastel-purple: #D1A6F0;
  --peach-pink: #FFABAB;
  --soft-lavender: #C1A2D2;
  --ocean-blue: #2C3E50;
}


body{
  background: transparent;
}
body ::placeholder{
  background-color: transparent !important;
}


@font-face {
  font-family: 'Sans-Mono-400';
  src: url('./assets/Google Sans Mono-normal-400-100.ttf');

}
@font-face {
  font-family: 'Sans-Mono-300';
  src: url('./assets/Google Sans Mono-normal-300-100.ttf');

}



@font-face {
  font-family: 'Sans-Mono-500';
  src: url('./assets/Google Sans Mono-normal-500-100.ttf');
}
@font-face {
  font-family: 'Sans-Mono-700';
  src: url('./assets/Google Sans Mono-normal-700-100.ttf');
}
@font-face {
  font-family: 'Sans-Text-400';
  src: url('./assets/Google Sans Text-normal-400-100.ttf');
}
@font-face {
  font-family: 'Sans-Text-700';
  src: url('./assets/Google Sans Text-normal-700-100.ttf');
  
}
@font-face {
  font-family: 'Nanum Myeongjo';
  src: url('./assets/NanumMyeongjo-Regular.ttf');
  font-weight: 400;
  font-style: normal;
}


.nanum-myeongjo-regular {
  font-family: "Gilda Display", serif;
  font-weight: 400;
  font-style: normal;
}
.nyr {
  font-family: "Gilda Display", serif;
  font-weight: 400;
  font-style: normal;
}
.nyr-semibold {
  font-family: "Nanum Myeongjo", serif;
  font-weight: 500;
  font-style: normal;
}

.nanum-myeongjo-bold {
  font-family: "Nanum Myeongjo", serif;
  font-weight: 700;
  font-style: normal;
}

.nanum-myeongjo-extrabold {
  font-family: "Nanum Myeongjo", serif;
  font-weight: 800;
  font-style: normal;
}

.inter-400{
  font-family: "Inter", serif;
  font-optical-sizing: auto;
  font-weight: 400;
  font-style: normal;
}
.inter-500{
  font-family: "Inter", serif;
  font-optical-sizing: auto;
  font-weight: 500;
  font-style: normal;
}
.inter-600{
  font-family: "Inter", serif;
  font-optical-sizing:auto;
  font-weight: 600;
  font-style: normal;
}
.inter-700{
  font-family: "Inter", serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
}

.noto-sans-mono-400 {
  font-family: "Noto Sans Mono", serif;
  font-optical-sizing: auto;
  font-weight: 400;
  font-style: normal;
  font-variation-settings:
    "wdth" 100;
}
.noto-sans-mono-500 {
  font-family: "Noto Sans Mono", serif;
  font-optical-sizing: auto;
  font-weight: 500;
  font-style: normal;
  font-variation-settings:
    "wdth" 100;
}
.noto-sans-mono-600 {
  font-family: "Noto Sans Mono", serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-variation-settings:
    "wdth" 100;
}

.Georgia{font-family: 'Georgia', sans-serif;}

textarea{
  resize: none;
  margin: 0px !important;
}




================================================
FILE: frontend/src/main.tsx
================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import  MorningComponent from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <MorningComponent />
  </StrictMode>,
)



================================================
FILE: frontend/src/supabaseClient.ts
================================================
import { createClient} from "@supabase/supabase-js";

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

export const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);



================================================
FILE: frontend/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: frontend/src/assets/Google Sans Mono-normal-400-100.ttf
================================================
[Binary file]


================================================
FILE: frontend/src/assets/Google Sans Mono-normal-500-100.ttf
================================================
[Binary file]


================================================
FILE: frontend/src/assets/Google Sans Mono-normal-700-100.ttf
================================================
[Binary file]


================================================
FILE: frontend/src/assets/Google Sans Text-normal-400-100.ttf
================================================
[Binary file]


================================================
FILE: frontend/src/assets/Google Sans Text-normal-700-100.ttf
================================================
[Binary file]


================================================
FILE: frontend/src/components/AuthComponent.tsx
================================================
[Empty file]


================================================
FILE: frontend/src/components/AuthLoadingIndicator.tsx
================================================
import { motion } from 'framer-motion';
import LoaderPillars from './LoaderPillars';

interface AuthLoadingIndicatorProps {
  message?: string;
  showDetails?: boolean;
}

const AuthLoadingIndicator = ({ 
  message = "Setting things up for you...", 
  showDetails = false 
}: AuthLoadingIndicatorProps) => {
  return (
    <motion.div 
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3, ease: "easeOut" }}
      className="h-[500px] w-[100%] relative border border-black rounded-lg overflow-hidden"
    >
      {/* Background with colored sections */}
      <div className="absolute inset-0 flex">
        <div className="w-1/4 bg-[var(--primary-orange)]" />
        <div className="w-1/4 bg-[var(--primary-green)]" />
        <div className="w-1/4 bg-[var(--primary-yellow)]" />
        <div className="w-1/4 bg-[var(--primary-blue)]" />
      </div>

      {/* Content */}
      <div className="relative h-full w-full flex items-center justify-center">
        <div className="flex flex-col items-center text-center space-y-8">
          <p className="text-4xl nyr max-w-md">
            "{message}"
          </p>
          
          {/* Loader animation */}
          <LoaderPillars />
          
          {showDetails && (
            <motion.div 
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.5, duration: 0.3 }}
              className="text-sm text-gray-600 max-w-sm"
            >
              <p>Validating authentication...</p>
            </motion.div>
          )}
        </div>
      </div>
    </motion.div>
  );
};

export default AuthLoadingIndicator;



================================================
FILE: frontend/src/components/Button.tsx
================================================
import '../index.css';

interface Props {
    handle: () => void;
    text: string;
    textColor: string; 
    iSdisabled ?: boolean;
    IncMinWidth?:string;
  }
  
  export default function Button({ handle, text, textColor, iSdisabled,IncMinWidth }: Props) {

    return (
      <button
        type="button"
        onClick={handle}
        style={{color:`var(${textColor})`, minWidth: IncMinWidth ? `${IncMinWidth}`: '118px'}}
        className={`bg-black px-6 py-3 rounded-full 
                    hover:bg-transparent hover:text-black transition-colors
                    inter-500 text-xs border border-black tracking-wider`}
        onMouseEnter={(e) => (e.currentTarget.style.color = "black")}
        onMouseLeave={(e) => (e.currentTarget.style.color = `var(${textColor})`)}
        disabled={iSdisabled}
        
      >
        {iSdisabled ? '' : text}
      </button>
    );
  }
  


================================================
FILE: frontend/src/components/Cards.tsx
================================================
import { RiArrowRightUpLine } from "react-icons/ri";
import { MdDelete } from "react-icons/md";
import { MdOutlineEditNote } from "react-icons/md";

interface CardProps {
    title: string;
    description: string;
    bgColor: string;
    onClick: () => void;
    isSelected: boolean;
    RedirectUrl?:string;
    date:string
    confirmDelete:boolean;
    setDeleteClicked:(vale: boolean) => void;
    isSearchAll:boolean;
    type:string;
    activeTab:string;
}



export default function Cards({ title, description, bgColor,onClick,isSelected,RedirectUrl,date,confirmDelete,setDeleteClicked,
type,
activeTab,
isSearchAll

 }: CardProps) {
  console.log("The type is:", type);

    return (
        <>
          <div
            className={`${bgColor} rounded-lg p-4 mb-4 relative cursor-pointer flex-col justify-between
            ${
              isSelected
                ? `scale-100 min-h-[415px] w-[100%]`
                : 'scale-100 h-[130px] hover:scale-[1.02] overflow-hidden'
            } transition-all duration-500 ease-in-out will-change-transform
            
            
            `}
            onClick={onClick}
            style={{
              ...(!isSearchAll && (type !== activeTab && activeTab !== "All")  ? { display: 'none' } : {})
            }}
            
          >
            <div 
              className={`flex justify-between items-start overflow-hidden ${bgColor}`}
            >
           {isSelected ? 
           
           <button 
                   disabled={confirmDelete}
                   className={`p-0 flex-shrink-0 ${bgColor}`}>
                     <MdDelete
                     onClick={()=>setDeleteClicked(true)}
                     size={24} className="self-start"/>
              </button>

           
           :null}
              <div 
                className={`flex-1 min-w-0 ${isSelected ? 'p-14 pt-28 pr-8' : 'pr-8'} ${bgColor}`}
              >
                {isSelected ? (
                  <p className="nyr text-[16px] mb-2 truncate">{date}</p>
                ) : null}
                <h2 className={`text-[22px] nyr mb-[0.8rem] leading-tight ${
                  isSelected 
                    ? 'break-words' 
                    : 'truncate'
                }`}>
                  {isSelected
                    ? title
                    : title}
                </h2>
                <div 
                  className={`font-SansMono400 text-sm leading-snug opacity-90 ${
                    isSelected 
                      ? 'pb-[45px] break-words max-h-[180px] overflow-y-auto scrollbar-hide' 
                      : 'line-clamp-2'
                  }`}
                  style={{ backgroundColor: `var(${bgColor})` }}
                  onClick={(e) => {
                    if (isSelected) {
                      e.stopPropagation();
                    }
                  }}
                >
                  {description}
                </div>
              </div>
             <div className="flex-shrink-0 w-[10%] min-w-[40px] flex flex-col justify-start items-end" style={{ backgroundColor: `var(${bgColor})` }}>
             <div className="w-full flex justify-end mb-2" style={{ backgroundColor: `var(${bgColor})` }}>
                {
                  RedirectUrl ?
                  <RiArrowRightUpLine size={28} className={type === "Note" ? "cursor-default opacity-50" : "cursor-pointer"} onClick={()=>{isSelected && type !== "Note" ? window.open(RedirectUrl) : null}}/>
                  :
                  <MdOutlineEditNote size={28} className={type === "Note" ? "cursor-default opacity-50" : "cursor-pointer"} onClick={()=>{isSelected && type !== "Note" ? window.open(RedirectUrl) : null}}/>
                }
              </div>
              {isSelected && type !== "Note" && RedirectUrl && (
                <div className="w-full flex justify-end" style={{ backgroundColor: `var(${bgColor})` }}>
                  <p className="font-SansMono400 text-[10px] mt-1 truncate max-w-full text-right">
                    {RedirectUrl.split("//")[1]?.split("/")[0] || RedirectUrl}
                  </p>
                </div>
              )}
             </div>
            </div>
          </div>
        </>
      );
      
      
}


================================================
FILE: frontend/src/components/ClickSpark.tsx
================================================
import React, { useRef, useEffect, useCallback } from "react";

interface ClickSparkProps {
  sparkColor?: string;
  sparkSize?: number;
  sparkRadius?: number;
  sparkCount?: number;
  duration?: number;
  easing?: "linear" | "ease-in" | "ease-out" | "ease-in-out";
  extraScale?: number;
  children?: React.ReactNode;
}

interface Spark {
  x: number;
  y: number;
  angle: number;
  startTime: number;
}

const ClickSpark: React.FC<ClickSparkProps> = ({
  sparkColor = "#fff",
  sparkSize = 10,
  sparkRadius = 15,
  sparkCount = 8,
  duration = 400,
  easing = "ease-out",
  extraScale = 1.0,
    children
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const sparksRef = useRef<Spark[]>([]); 
  const startTimeRef = useRef<number | null>(null); 

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const parent = canvas.parentElement;
    if (!parent) return;

    let resizeTimeout : NodeJS.Timeout;

    const resizeCanvas = () => {
      const { width, height } = parent.getBoundingClientRect();
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    };

    const handleResize = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(resizeCanvas, 100); // Debounce by 100ms
    };

    // Observe size changes
    const ro = new ResizeObserver(handleResize);
    ro.observe(parent);

    // Initial sizing
    resizeCanvas();

    // Cleanup
    return () => {
      ro.disconnect();
      clearTimeout(resizeTimeout);
    };
  }, []);


  const easeFunc = useCallback(
      (t: number) => {
        switch (easing) {
          case "linear":
            return t;
          case "ease-in":
            return t * t;
          case "ease-in-out":
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          default:
            return t * (2 - t);
        }
      },
      [easing]
  );

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    let animationId: number;

    const draw = (timestamp: number) => {
      if (!startTimeRef.current) {
        startTimeRef.current = timestamp; // store initial time
      }
      ctx?.clearRect(0, 0, canvas.width, canvas.height);

      sparksRef.current = sparksRef.current.filter((spark: Spark) => {
        const elapsed = timestamp - spark.startTime;
        if (elapsed >= duration) {
          // Spark finished its animation
          return false;
        }

        const progress = elapsed / duration;
        const eased = easeFunc(progress);

        const distance = eased * sparkRadius * extraScale;
        const lineLength = sparkSize * (1 - eased);

        // Points for the spark line
        const x1 = spark.x + distance * Math.cos(spark.angle);
        const y1 = spark.y + distance * Math.sin(spark.angle);
        const x2 = spark.x + (distance + lineLength) * Math.cos(spark.angle);
        const y2 = spark.y + (distance + lineLength) * Math.sin(spark.angle);

        // Draw the spark line
        ctx.strokeStyle = sparkColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        return true;
      });

      animationId = requestAnimationFrame(draw);
    };

    animationId = requestAnimationFrame(draw);

    return () => {
      cancelAnimationFrame(animationId);
    };
  }, [sparkColor, sparkSize, sparkRadius, sparkCount, duration, easeFunc, extraScale]);

    const handleClick = (e: React.MouseEvent<HTMLDivElement>): void => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const now = performance.now();
    const newSparks: Spark[] = Array.from({length: sparkCount}, (_, i) => ({
      x,
      y,
      angle: (2 * Math.PI * i) / sparkCount,
      startTime: now,
    }));

    sparksRef.current.push(...newSparks);
  };

    return (
        <div
          className="relative w-full h-full z-[999]"
          onClick={handleClick}
        >
            <canvas
                ref={canvasRef}
                className="absolute inset-0 pointer-events-none z-[9999]"
            />
            {children}
        </div>
    );
};

export default ClickSpark;



================================================
FILE: frontend/src/components/InputForm.tsx
================================================
import { useEffect, useState, useRef } from "react";
import Button from "./Button";
import LoaderPillars from "./LoaderPillars";
import { BsChevronDoubleDown } from "react-icons/bs";

interface Props {
  handleSubmit: any,
  handleClear: any,
  formData: FormData,
  handleChange: any
  BtnTxtClr: string
  leftBtnTxt: string,
  rightBtnTxt: string
  showOnlyOne?: boolean;
  Error?: string;
  isLoading?: boolean;
  currentTab: string;
  setCurrentTab: (tab: string) => void;
  extraNote: string;
  setExtraNote: (note: string) => void;
  NotesTitle: string;
  setNotesTitle: (title: string) => void;
}
interface FormData {
  link: string;
  title: string;
  note: string;
}

export default function InputForm({
  handleSubmit,
  handleChange,
  handleClear,
  formData,
  BtnTxtClr,
  leftBtnTxt,
  rightBtnTxt,
  showOnlyOne,
  Error,
  isLoading,
  extraNote,
  setExtraNote,
  NotesTitle,
  setNotesTitle,
  setCurrentTab
}: Props) {
  const [showNotes, setShowNotes] = useState(false);
  const notesTextAreaRef = useRef<HTMLTextAreaElement>(null);
  const titleTextAreaRef = useRef<HTMLTextAreaElement>(null);
  const bookmarkNoteRef = useRef<HTMLTextAreaElement>(null);
  
  // Auto-focus on bookmark note area when extension opens (default behavior)
  useEffect(() => {
    if (!showNotes && bookmarkNoteRef.current && !isLoading && !showOnlyOne) {
      // Small delay to ensure DOM is ready
      const timer = setTimeout(() => {
        bookmarkNoteRef.current?.focus();
      }, 200);

      return () => clearTimeout(timer);
    }
  }, [showNotes, isLoading, showOnlyOne]);
  
  // Focus the notes text area when notes tab becomes active
  useEffect(() => {
    if (showNotes && notesTextAreaRef.current && !isLoading && !showOnlyOne) {
      // Small delay to ensure the transition animation completes
      const timer = setTimeout(() => {
        notesTextAreaRef.current?.focus();
      }, 200);

      return () => clearTimeout(timer);
    }
  }, [showNotes, isLoading, showOnlyOne]);

  useEffect(()=>{
    if(showNotes){
      setCurrentTab("notes")
    }else{
      setCurrentTab("submit")
    }
  },[showNotes])


  return (
    <form onSubmit={handleSubmit} className="space-y-5">
      {!showNotes ? (<div
        className={`form-input-div space-y-4 transition-all duration-500 ${
          showNotes ? "opacity-0 pointer-events-none " : "opacity-100"
        }`}
      >
        <div className="space-y-1">
          <label className="block text-sm font-SansMono400">Link:</label>
          <input
            type="text"
            name="link"
            autoComplete="off"
            value={formData.link}
            onChange={handleChange}
            className="w-full border-b border-black bg-transparent focus:outline-none  pb-1 placeholder-[#151515] placeholder-opacity-25"
            placeholder="Your link here"
            disabled={isLoading || showOnlyOne}
          />
        </div>

        <div className="space-y-1">
          <label className="block text-sm font-SansMono400">Title:</label>
          <input
            type="text"
            name="title"
            value={formData.title}
            onChange={handleChange}
            className="w-full border-b border-black bg-transparent focus:outline-none pb-1 placeholder-[#151515] placeholder-opacity-25"
            placeholder="Your title here"
            disabled={isLoading || showOnlyOne}
          />
        </div>

        <div className="space-y-1">
          <label className="block text-sm font-SansMono400">Note:</label>
          <textarea
            ref={bookmarkNoteRef}
            name="note"
            rows={2}
            value={formData.note}
            onChange={handleChange}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                if (formData.link.trim() !== "" && formData.title.trim() !== "" && formData.note.trim() !== "") {
                  handleSubmit(e);
                }
              }
            }}
            className="w-full border-b border-black bg-transparent focus:outline-none placeholder-[#151515] placeholder-opacity-25 py-1 scrollbar-hide"
            placeholder="Add micro-note for better search results (press Enter to save)"
            disabled={isLoading || showOnlyOne}
          />
        </div>

      </div>) :

      (<div
        className={`space-y-2 transition-all duration-500 w-full pb-1 ${
          showNotes ? "opacity-100 translate-y-0 z-10" : "opacity-0 pointer-events-none -translate-y-10"
        }`}
      >
        <label className="block text-md font-SansMono400 text-[15px] ">Title:</label>
        <textarea
          ref={titleTextAreaRef}
          rows={1}
          value={NotesTitle}
          onChange={e => setNotesTitle(e.target.value)}
          className="w-full bg-transparent focus:outline-none placeholder-[#151515] placeholder-opacity-25 py-3  border-b border-black scrollbar-hide"
          placeholder="Your title here..."
          disabled={isLoading || showOnlyOne}
        />
        <label className="block text-md font-SansMono400 text-[15px] ">Note:</label>
        <textarea
          ref={notesTextAreaRef}
          rows={2}
          value={extraNote}
          onChange={e => setExtraNote(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              if (NotesTitle.trim() !== "" && extraNote.trim() !== "") {
                handleSubmit(e);
              }
            }
          }}
          className="w-full bg-transparent focus:outline-none placeholder-[#151515] placeholder-opacity-25 py-3  border-b border-black scrollbar-hide"
          placeholder="Write your note here... (Press Enter to save)"
          disabled={isLoading || showOnlyOne}
        />
      </div>)}

        <div className="flex justify-center mt-0">
          {!showOnlyOne && !Error && (
            <button
              type="button"
              className="text-neutral-700 bg-white/20 rounded-full px-4 py-2 flex justify-center items-center gap-1 mt-2  text-sm transition hover:text-black"
              onClick={() => setShowNotes(!showNotes)}
              disabled={isLoading || showOnlyOne}
            >
              <BsChevronDoubleDown size={12} /> { showNotes ? "Add Bookmarks" : "Add Notes"}
            </button>
          )}
        </div>

      {Error ? (
        <div className="pb-0 mb-0 space-y-0">
          <p className="text-red-500 font-SansMono400 text-sm text-center pb-0">{Error}</p>
        </div>
      ) : null}

      <div className={`flex ${showOnlyOne ? 'justify-center' : 'justify-between'} mx-auto ${Error ? "pt-0" : "pt-1"}`}>
        {isLoading ? (
          <div className="flex justify-center w-full">
            <LoaderPillars />
          </div>
        ) : (
          <>
            <Button handle={handleClear} text={leftBtnTxt} textColor={BtnTxtClr} iSdisabled={false} />
            {showOnlyOne ? null : <Button handle={handleSubmit} text={rightBtnTxt} textColor={BtnTxtClr} IncMinWidth="129px" iSdisabled={false} />}
          </>
        )}
      </div>
    </form>
  );
}


================================================
FILE: frontend/src/components/Loader.tsx
================================================



const ColorChangingSpinner = () => {
  const blades = Array.from({ length: 12 }, (_, i) => i * 30);
  
  return (
    <div className="flex justify-center items-center h-[12px] bg-transparent mt-[6px]">
      <div className="w-9 h-9 relative">
        {blades.map((angle, index) => (
          <div
            key={angle}
            className="absolute w-[2px] h-[9px] rounded-sm origin-[50%_150%] opacity-25"
            style={{
              left: 'calc(50% - 1.25px)',
              top: '25%',
              transform: `rotate(${angle}deg)`,
              animation: 'spinner-blade 1.2s linear infinite',
              animationDelay: `${-0.1 * index}s`,
            }}
          />
        ))}
      </div>

      <style>{`
        @keyframes spinner-blade {
          0% {
            opacity: 0.25;
            transform: rotate(inherit) scaleY(1);
            background-color: black;
          }
          50% {
            opacity: 1;
            transform: rotate(inherit) scaleY(1.5);
            background-color: black;
          }
          65% {
            opacity: 0.25;
            transform: rotate(inherit) scaleY(0.75);
            background-color: black;
          }
          85% {
            opacity: 0.25;
            transform: rotate(inherit) scaleY(1);
            background-color: black;
          }
          100% {
            opacity: 0.25;
            transform: rotate(inherit) scaleY(1);
            background-color: black;
          }
        }
      `}</style>
    </div>
  );
};

export default ColorChangingSpinner;


================================================
FILE: frontend/src/components/LoaderPillars.tsx
================================================
import { motion } from "framer-motion";

const LoaderPillars = () => {
  return (
    <div className="grid place-content-center bg-transparent h-[30px] mt-1">
      <BarLoader />
    </div>
  );
};

const variants = {
  initial: {
    scaleY: 0.5,
    opacity: 0,
  },
  animate: {
    scaleY: 1,
    opacity: 1,
    transition: {
      repeat: Infinity,
      repeatType: "mirror" as const,
      duration: 1,
      ease: "circIn",
    },
  },
};

const BarLoader = () => {
  return (
    <motion.div
      transition={{
        staggerChildren: 0.25,
      }}
      initial="initial"
      animate="animate"
      className="flex gap-[3px]"
    >
      <motion.div variants={variants} className="h-4 w-1 bg-black" />
      <motion.div variants={variants} className="h-4 w-1 bg-black" />
      <motion.div variants={variants} className="h-4 w-1 bg-black" />
      <motion.div variants={variants} className="h-4 w-1 bg-black" />
      <motion.div variants={variants} className="h-4 w-1 bg-black" />
    </motion.div>
  );
};

export default LoaderPillars;


================================================
FILE: frontend/src/components/ProtectedRoute.tsx
================================================
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useSimpleAuth } from './SimpleAuth';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, loading: isLoading } = useSimpleAuth();

  console.log('🛡️ PROTECTED_ROUTE: Checking access', { isAuthenticated, isLoading });

  // Show loading while checking authentication status
  if (isLoading) {
    console.log('⏳ PROTECTED_ROUTE: Still loading auth status');
    return (
      <div className="h-[500px] w-[420px] bg-white rounded-lg border border-black flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-black mx-auto mb-4"></div>
          <p className="text-sm text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  // Redirect to intro page if not authenticated
  if (!isAuthenticated) {
    console.log('🚫 PROTECTED_ROUTE: User not authenticated, redirecting to intro');
    return <Navigate to="/" replace />;
  }

  console.log('✅ PROTECTED_ROUTE: User authenticated, allowing access');
  return <>{children}</>;
};

export default ProtectedRoute;



================================================
FILE: frontend/src/components/SimpleAuth.tsx
================================================
// Simple authentication hook based on OauthImplementation.md

import React, { useState, useEffect } from 'react';
import { logout, checkAuthStatus } from '../utils/api';

// Extend Window interface to include our auth check flag
declare global {
  interface Window {
    authChecked?: boolean;
  }
}

const SUPABASE_URL = "https://dzftiemmhvmtrlooukqd.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR6ZnRpZW1taHZtdHJsb291a3FkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg2MTQ5NjEsImV4cCI6MjA1NDE5MDk2MX0.pFPUNjrL52biBlNmwcSwJRxhQ7mx1Elqnh_6OOVABM4";

// Function to refresh tokens
async function refreshTokens(refreshToken: string) {
  const refreshResponse = await fetch(`${SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`, {
    method: 'POST',
    headers: {
      'apikey': SUPABASE_ANON_KEY,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      refresh_token: refreshToken
    }),
  });

  if (!refreshResponse.ok) {
    const errorData = await refreshResponse.text();
    throw new Error(`Token refresh failed: ${refreshResponse.status} ${errorData}`);
  }
  
  const newTokens = await refreshResponse.json();
  
  // Save both the new access token and refresh token
  await chrome.storage.local.set({
    access_token: newTokens.access_token,
    refresh_token: newTokens.refresh_token || refreshToken
  });
  
  return newTokens;
}

interface User {
  id: string;
  email: string;
  full_name?: string;
  sub?: string;
  profile_pic?: string;
}

interface AuthResult {
  success: boolean;
  error?: string;
}

export function useSimpleAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    // Prevent duplicate auth checks by using a global flag
    if (window.authChecked) {
      console.log('🔍 Auth check already performed, skipping duplicate check');
      setLoading(false);
      return;
    }
    
    window.authChecked = true;
    
    // Check if user is already logged in on component mount
    const checkUser = async () => {
      console.log('🔍 Checking if user is already logged in...');
      
      try {
        const tokens = await chrome.storage.local.get(["access_token", "refresh_token"]);
        
        if (!tokens.access_token) {
          console.log('❌ No access token found');
          setUser(null);
          setLoading(false);
          return;
        }
        
        // Check auth status with backend
        const authStatus = await checkAuthStatus();
        console.log('🔍 Auth status response:', authStatus);
        
        if (authStatus.is_authenticated && authStatus.token_valid) {
          console.log('✅ User is authenticated and token is valid');
          const profile = {
            id: authStatus.user_id,
            sub: authStatus.user_id,
            email: authStatus.user_email,
            full_name: authStatus.full_name || authStatus.user_name,
            profile_pic: authStatus.picture || authStatus.user_picture
          };
          setUser(profile);
        } else if (authStatus.has_access_token === false && authStatus.has_refresh_token === false) {
          console.log('❌ No tokens on backend, need to re-authenticate');
          // Clear local tokens and redirect to auth
          await chrome.storage.local.remove(['access_token', 'refresh_token']);
          setUser(null);
        } else {
          console.log('❌ Token invalid or user not authenticated:', authStatus);
          // Try to refresh token if we have a refresh token
          if (tokens.refresh_token) {
            console.log('🔄 Attempting to refresh token...');
            try {
              await refreshTokens(tokens.refresh_token);
              // After refresh, try checking auth status again
              const newAuthStatus = await checkAuthStatus();
              if (newAuthStatus.is_authenticated) {
                const profile = {
                  id: newAuthStatus.user_id,
                  sub: newAuthStatus.user_id,
                  email: newAuthStatus.user_email,
                  full_name: newAuthStatus.full_name || newAuthStatus.user_name,
                  profile_pic: newAuthStatus.picture || newAuthStatus.user_picture
                };
                setUser(profile);
              } else {
                setUser(null);
              }
            } catch (refreshError: any) {
              console.log('❌ Token refresh failed:', refreshError.message);
              await chrome.storage.local.remove(['access_token', 'refresh_token']);
              setUser(null);
            }
          } else {
            setUser(null);
          }
        }
      } catch (e: any) {
        console.log('❌ Auth check failed:', e.message);
        setUser(null);
      } finally {
        setLoading(false);
      }
    };
    checkUser();
  }, []);
  
  const handleLogin = (): Promise<AuthResult> => {
    return new Promise((resolve) => {
      const redirectUri = chrome.identity.getRedirectURL();
      const authUrl = `${SUPABASE_URL}/auth/v1/authorize?provider=google&redirect_to=${encodeURIComponent(redirectUri)}`;

      chrome.identity.launchWebAuthFlow({
        url: authUrl,
        interactive: true,
      }, async (redirectedTo) => {
        if (chrome.runtime.lastError || !redirectedTo) {
          console.log('❌ Login failed:', chrome.runtime.lastError?.message || 'Please try again.');
          const errorMsg = "Login failed. " + (chrome.runtime.lastError?.message || "Please try again.");
          setError(errorMsg);
          resolve({ success: false, error: errorMsg });
          return;
        }
        
        console.log('🔗 Redirect URL received:', redirectedTo);
        
        const url = new URL(redirectedTo);
        const fragment = new URLSearchParams(url.hash.substring(1));
        const accessToken = fragment.get('access_token');
        const refreshToken = fragment.get('refresh_token');
        
        console.log('🔑 Token extraction results:');
        console.log(`   - Access Token: ${accessToken ? accessToken.substring(0, 20) + '...' : 'Not found'}`);
        console.log(`   - Refresh Token: ${refreshToken ? refreshToken.substring(0, 20) + '...' : 'Not found'}`);

        if (accessToken && refreshToken) {
          console.log('💾 Storing tokens in chrome.storage.local...');
          await chrome.storage.local.set({ access_token: accessToken, refresh_token: refreshToken });
          console.log('✅ Tokens stored successfully');
          
          // Set a basic user object to mark as authenticated
          setUser({ id: 'authenticated', email: '', full_name: 'User' });
          setError('');
          resolve({ success: true });
        } else {
          console.log('❌ Token extraction failed - missing tokens');
          const errorMsg = "Could not retrieve tokens from Supabase.";
          setError(errorMsg);
          resolve({ success: false, error: errorMsg });
        }
      });
    });
  };

  const handleLogout = async () => {
    await logout();
    setUser(null);
    setError('');
  };

  // Check if user is authenticated (has tokens)
  const isAuthenticated = () => {
    return user !== null;
  };

  return {
    user,
    loading,
    error,
    isAuthenticated: isAuthenticated(),
    login: handleLogin,
    logout: handleLogout
  };
}

// Simple component that uses the hook for backward compatibility
interface SimpleAuthProps {
  children?: (auth: ReturnType<typeof useSimpleAuth>) => React.ReactNode;
}

export default function SimpleAuth({ children }: SimpleAuthProps) {
  const auth = useSimpleAuth();
  
  if (auth.loading) {
    return <div>Loading...</div>;
  }
  
  return children ? children(auth) : null;
}



================================================
FILE: frontend/src/components/toggleTab.tsx
================================================

export default function ToggleTabs({activeTab,setActiveTab,tabs}:{activeTab:string, setActiveTab:(tab:string) => void,tabs:string[]}) {
  

  return (
    <div className="flex justify-center items-center">
        <div className="fixed top-3 z-[99999] bg-white drop-shadow-2xl flex border-[1.5px] border-black  rounded-full p-0.5 space-x-2 max-h-[43px]">
            {tabs.map((tab) => (
                <button
                    key={tab}
                    onClick={() => setActiveTab(tab)}
                    className={`px-3 py-[8px] rounded-full transition-all duration-300 ease-in-out
                        ext-black text-[10px] font-SansText400  tracking-widest
                        ${
                        activeTab === tab
                            ? "bg-lime-300 text-gray-800 shadow-sm"
                            : "text-gray-600 hover:text-gray-800 "
                    }`}
                >
                    {tab !== "All" ? tab.toUpperCase() + "S"  : "ALL"}
                </button>
            ))}
        </div>
    </div>
  );
}


================================================
FILE: frontend/src/config/environment.ts
================================================
// Environment configuration for the application
export const config = {
  BACKEND_URL: import.meta.env.VITE_BACKEND_URL,
  API_URL: import.meta.env.VITE_API_URL,
  SUPABASE_URL: import.meta.env.VITE_SUPABASE_URL,
  SUPABASE_ANON_KEY: import.meta.env.VITE_SUPABASE_ANON_KEY,
};

// For use in public scripts (background.js, content.js)
// This will be injected during build process
export const getEnvironmentConfig = () => {
  return {
    BACKEND_URL: '__VITE_BACKEND_URL__',
    API_URL: '__VITE_API_URL__'
  };
};



================================================
FILE: frontend/src/page/IntroPage.tsx
================================================
import Button from "../components/Button";
import Logo from '../assets/Logo.svg'
import '../index.css'
import { useNavigate } from 'react-router-dom';
import {motion} from 'framer-motion';
import { useSimpleAuth } from '../components/SimpleAuth';
import { useState } from 'react';

const Intro = () => {
    const Navigate = useNavigate();
    const { login } = useSimpleAuth();
    const [error, setError] = useState('');

    const handleAuth = async () => {
        console.log('🚀 Initiating simplified authentication');
        setError(''); // Clear any previous errors
        
        const result = await login();
        if (result.success) {
            Navigate("/submit");
        } else {
            console.error('❌ Login failed:', result.error);
            setError(result.error || 'Authentication failed');
        }
    };

    return (
        <motion.div 
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 1.5, ease: "ease" }}
        className="h-[500px] w-[100%] relative border border-black rounded-lg overflow-hidden">

          <div className="absolute inset-0 flex">
            <div className="w-1/4 bg-[var(--primary-orange)]" />
            <div className="w-1/4 bg-[var(--primary-green)]" />
            <div className="w-1/4 bg-[var(--primary-yellow)]" />
            <div className="w-1/4 bg-[var(--primary-blue)]" />
          </div>

          <div className="relative h-[500px] w-[419px] flex my-auto justify-center rounded-lg">
            <div className="flex flex-col items-center text-center space-y-8 p-8">

              <div className="flex items-center mb-16">
                <img src={Logo} alt="" className="pl-6"/>
              </div>

              <p className="text-4xl nyr max-w-md">
                "Every bookmark is a doorway to a new journey"
              </p>

              {error && (
                <div className="text-red-500 text-sm max-w-md">
                  {error}
                </div>
              )}

              <Button handle={handleAuth} text="GET STARTED" textColor="--primary-white"/>
            </div>
          </div>
        </motion.div>
    );
};

export default Intro;



================================================
FILE: frontend/src/page/ResponsePage.tsx
================================================
import { useNavigate } from "react-router-dom";
import InputForm from "../components/InputForm";
import { useState, useRef } from "react";
import { BiSearchAlt2 } from "react-icons/bi";
import '../index.css';
import isUrlHttp from "is-url-http";
import { submitLink, saveNotes } from "../utils/apiClient";

interface FormData {
  link: string;
  title: string;
  note: string;
}

export default function ResponsePage() {

  const [leftBtnTxt, setLftBtnTxt] = useState("SUMMARIZE");
  const [BtnTxtClr, setBtnTxtClr] = useState("--primary-yellow");
  const [rightBtnTxt, setRtBtnTxt] = useState("MEMORIZE");
  const [notSubmitted, setnotSubmitted] = useState(true);
  const [bgClr, setbgClr] = useState("--primary-yellow");
  const [isError, setisError] = useState('');
  const [showOnlyOne, setShowOnlyOne] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [currentTab, setCurrentTab] = useState("submit");
  const [extraNote, setExtraNote] = useState("");
  const [NotesTitle, setNotesTitle] = useState("");

  const Navigate = useNavigate();
  const [DoneNumber, setDoneNumber] = useState(0);
  const isNavigating = useRef(false);

  function isValidURL(url:string) {
        console.log("The url is:", url ,"and it is valid", isUrlHttp(url));
        return !isUrlHttp(url);
  }







  const [formData, setFormData] = useState<FormData>({
    link: '',
    title: '',
    note: ''
  });
  const getLink = () => {
    chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
      setFormData({ ...formData, link: tabs[0].url || '', title: tabs[0].title || '' })
    })
  }
  if (formData.link == "" && DoneNumber == 0) {
    getLink();
    setDoneNumber(1);
  }



  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };


  const handleResponse = async (e: React.FormEvent) => {
    e.preventDefault();


    if (currentTab === "submit" && (formData.link === "" || isValidURL(formData.link) || formData.title === "")) {
      setnotSubmitted(true);
      if(isValidURL(formData.link)){
        setisError("Enter a valid link!")
        return
      }
      setisError("Link or Title missing!")
      return
    }
    else if (currentTab === "notes" && (NotesTitle.trim() === "" || extraNote.trim() === "")) {
      setnotSubmitted(true);
      setisError("Title and Note are required!")
      return
    }
    else {
      setIsLoading(true);
      setisError('')
      setnotSubmitted(false);

      try {
        if (currentTab === "submit") {
          console.log("Frontend submitting link data:", formData);
          const response = await submitLink(formData);
          console.log("Frontend received link response:", response);
          
          setIsLoading(false);
          setbgClr("--primary-green")
          setLftBtnTxt("CLOSE")
          setBtnTxtClr("--primary-green")
          setRtBtnTxt("HOME")
          setShowOnlyOne(true)
        } else {
          const noteData = {
            title: NotesTitle,
            note: extraNote
          };
          console.log("Frontend submitting note data:", noteData);
          const response = await saveNotes(noteData);
          console.log("Frontend received note response:", response);
          
          setIsLoading(false);
          setbgClr("--primary-green")
          setLftBtnTxt("CLOSE")
          setBtnTxtClr("--primary-green")
          setRtBtnTxt("HOME")
          setShowOnlyOne(true)
        }
      } catch (error: any) {
        setIsLoading(false);
        console.error("API Error:", error);
        setbgClr("--primary-orange")
        setLftBtnTxt(currentTab === "submit" ? "Home" : "BACK")
        setBtnTxtClr("--primary-orange")
        setRtBtnTxt("RETRY :)")
        setisError(error?.message || "API Error")
      }
    }
  }

  const handleClear = () => {
    // Prevent multiple rapid clicks/navigation
    if (isNavigating.current) {
      return;
    }
    
    if (showOnlyOne && leftBtnTxt == "CLOSE") {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        const tabId = tabs[0].id;
        if(tabId){
          chrome.tabs.sendMessage(tabId, { 
            action: "closeExtension",
            target: "content"
          }, () => {
          });
        }
      });
    } else if (leftBtnTxt === 'Home') {
      Navigate(0);
    }
    else{
      // Set navigation flag and navigate to summarize
      isNavigating.current = true;
      Navigate("/summarize");
      
      // Reset flag after a delay to allow for normal navigation
      setTimeout(() => {
        isNavigating.current = false;
      }, 1000);
    }
  };

  return (
    <>

      <div className={`max-w-md bg-[var(${bgClr})] rounded-lg px-9 w-[420px] h-[500px] flex flex-col justify-between py-10
      border border-black`}>


        <div className="flex justify-between items-center mb-6 gap-2 ">
          <div className='flex flex-col justify-end  -gap-2'>
          </div>
          {notSubmitted ?
            <div
              className="group relative flex items-center cursor-pointer box-border bg-transparent 
             px-2 py-2 rounded-full "
              onClick={() => Navigate("/search")}
            >
              <input
                type="text"
                placeholder="SEARCH"
                className="bg-transparent focus:outline-none text-black placeholder:text-[11px] 
              placeholder:text-black w-[70px] font-SansText400 pb-[2px] 
              placeholder:tracking-widest cursor-pointer relative z-10"
              />
              <BiSearchAlt2 size={24} className="relative z-10" />

              {/* Animated border element */}
              <div className="absolute inset-0 before:absolute before:inset-0 before:border-[1.5px] 
                before:border-black before:rounded-full before:scale-100 
                before:transition-transform before:duration-300 before:ease-in-out 
                group-hover:before:scale-105 group-hover:before:border-2">
              </div>
            </div>

            : null}
        </div>


        <InputForm
          handleChange={handleChange}
          handleClear={handleClear}
          handleSubmit={handleResponse}
          formData={formData}
          BtnTxtClr={BtnTxtClr}
          leftBtnTxt={leftBtnTxt}
          rightBtnTxt={rightBtnTxt}
          Error={isError}
          showOnlyOne={showOnlyOne}
          isLoading={isLoading}
          currentTab={currentTab}
          setCurrentTab={setCurrentTab}
          extraNote={extraNote}
          setExtraNote={setExtraNote}
          NotesTitle={NotesTitle}
          setNotesTitle={setNotesTitle}
        />
        
      </div>
    </>
  );
}


================================================
FILE: frontend/src/page/SearchPage.tsx
================================================
import Button from "../components/Button";
import { useNavigate } from "react-router-dom";
import { motion } from "framer-motion";
import { useState, useRef, useEffect } from "react";
import ColorChangingSpinner from "../components/Loader";
import { GoBookmark } from "react-icons/go";
import { MdEditNote } from "react-icons/md";
import { removeSpacePattern } from "../utils/spaceUtils";
import { api } from "../utils/apiClient";


interface Props {
    Quote: string;
}



export default function SearchPage({ Quote }: Props) {
    const Navigate = useNavigate();
    const [query, setQuery] = useState<string>("");
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [isError, setisError] = useState<boolean>(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const [activeTab, setActiveTab] = useState("All");
    const [isFilterOpen, setIsFilterOpen] = useState(false);
    const [showSuggestion, setShowSuggestion] = useState(true);

    // const tabs = ["All", "Bookmarks", "Notes"];

    useEffect(() => {
        inputRef.current?.focus();
    }, []);

    useEffect(() => {
        const timer = setTimeout(() => {
            setShowSuggestion(false);
        }, 3500);

        return () => clearTimeout(timer);
    }, []);

    const handleSearch = async () => {
        setIsLoading(true);
        try {
            console.log('🔍 SEARCH: Starting search request via apiClient');
            
            const requestBody: any = {
                query: query
            };

            if (activeTab !== "All") {
                requestBody.filter = { type: { $eq: activeTab } };
            }

            const response = await api.post('/links/search', requestBody);
            
            if (response?.detail === "Search failed: No documents found matching query") {
                Navigate("/response", { state: { data: [] } });
                return;
            } else {
                console.log("The response is:", response);
                const responseArray = response.map((item: any) => ({
                    title: item.metadata.title,
                    url: item.metadata.source_url,
                    content: removeSpacePattern(item.metadata.note),
                    date: item.metadata.date,
                    ID: item.metadata.doc_id,
                    type: item.metadata.type
                }));
                Navigate("/response", { state: { data: responseArray, Query: query } });
            }
        } catch (error: any) {
            console.error("Search error:", error);
            const errorMessage = error?.message || "Search failed";
            
            if (errorMessage.includes("No documents found matching query")) {
                Navigate("/response", { state: { data: [], Query: query } });
            } else {
                Navigate("/response", { state: { data: [], Query: query, error: errorMessage } });
            }
        } finally {
            setIsLoading(false);
        }
    };
    const handleSearchAll = async () => {
        setIsLoading(true);
        try {
            console.log('🔍 SEARCH: Starting searchAll request via apiClient');
            
            // Make both API calls in parallel
            const [linksData, notesData] = await Promise.all([
                api.get('/links/get'),
                api.get('/notes/')
            ]);
            
            console.log('📦 SEARCH: Links data received via apiClient');
            console.log('📦 SEARCH: Notes data received via apiClient');
            
            const linksArray = linksData.map((item: any) => ({
                title: item.title,
                url: item.source_url,
                content: removeSpacePattern(item.note),
                date: item.date,
                ID: item.doc_id,
                type: item.type
            }));
            const notesArray = notesData.map((item: any) => ({
                title: item.title,
                content: removeSpacePattern(item.note),
                date: item.date,
                ID: item.doc_id,
                type: item.type
            }));
            
            console.log("The links array is from search all: ", linksArray);
            console.log("The notes array is from search all:", notesArray);
            const responseArray = [...linksArray, ...notesArray];
            Navigate("/response", { state: {data: responseArray, Query: " ", isSearchAll:true} });
            
        } catch (error: any) {
            console.error("SearchAll Error:", error);
            
            // Enhanced authentication error detection
            const errorMessage = error?.message || '';
            const isAuthError = (
                errorMessage.includes('Authentication required') ||
                errorMessage.includes('authentication failed') ||
                errorMessage.includes('fetch failed: 401') ||
                errorMessage.includes('401') ||
                errorMessage.includes('Session expired') ||
                errorMessage.includes('Please log in again') ||
                errorMessage.includes('Invalid Refresh Token')
            );
            
            if (isAuthError) {
                console.log("🚫 SEARCH: Authentication error detected, redirecting to intro page");
                Navigate("/");
                return;
            }
            
            // Handle other errors
            Navigate("/response", { 
                state: { 
                    data: [], 
                    Query: " ", 
                    isSearchAll: true, 
                    error: error?.message || "Failed to fetch data" 
                } 
            });
        } finally {
            setIsLoading(false);
        }
    };




    return (
        <>

                <div className="max-w-md bg-white rounded-lg px-10 w-[420px] h-[500px] flex flex-col  justify-between py-10 border border-black">
                    <div className=" flex flex-col gap-2 ">
                    <div className="relative flex border-black border-[1.5px] rounded-full px-1 py-1 justify-between min-h-[43px]
                font-SansText400">
                        
                        {/* Conditionally render either the search input OR the filter options */}
                        {!isFilterOpen ? (
                            // Search Input State
                            <>
                                <input
                                    ref={inputRef}
                                    type="text"
                                    placeholder={`SEARCH ${activeTab==="All" ? "BOOKMARKS & NOTES" : activeTab.toLocaleUpperCase()} - PRESS ENTER`}
                                    value={query}
                                    onChange={(e) => setQuery(e.target.value)}
                                    onKeyDown={(e) => {
                                        if (e.key === "Enter") {
                                            if (query.length < 3) {
                                                setisError(true)
                                            }
                                            else {
                                                handleSearch();
                                            }
                                        }
                                    }}
                                    className="bg-transparent focus:outline-none text-black placeholder:text-[11px] placeholder:text-black flex-grow
                                    font-SansText400 pb-[1px] placeholder:tracking-widest
                                    placeholdder-opacity-25 transition-all duration-300 ease-in-out"
                                />

                                {isLoading ? (
                                    <div>
                                        <ColorChangingSpinner />
                                    </div>
                                ) : (
                                    <div className="relative">
                                        <button
                                            onClick={() => setIsFilterOpen(!isFilterOpen)}
                                            className="bg-black h-full rounded-full">
                                            {activeTab === "All" && <p className="text-white px-2 py-1 font-SansText400 tracking-widest">ALL</p>}
                                            {activeTab === "Bookmark" && <GoBookmark size={18} color="white" className="w-[32px]"/>}
                                            {activeTab === "Note" && <MdEditNote size={18} color="white" className="w-[32px]" />}
                                        </button>

                                        {showSuggestion && (
                                            <motion.div
                                                initial={{ opacity: 0, y: -10 }}
                                                animate={{ opacity: 1, y: 0 }}
                                                exit={{ opacity: 0, y: -10 }}
                                                transition={{ duration: 0.3 }}
                                                className="absolute bg-[#dcdcdc] text-black right-0 top-[50px] px-4 py-2 rounded-full text-[10px] font-SansText400 tracking-wider whitespace-nowrap z-10"
                                            >
                                                click here to filter
                                                <div className="absolute -top-1 left-1/2 transform -translate-x-1/2 w-2 h-2 bg-[#dcdcdc] rotate-45"></div>
                                            </motion.div>
                                        )}
                                    </div>
                                )}
                            </>
                        ) : (
                            // Filter Selection State
                            <motion.div
                                initial={{ opacity: 0, x: 50 }}
                                animate={{ opacity: 1, x: 0 }}
                                exit={{ opacity: 0, x: 50 }}
                                transition={{ duration: 0.3, ease: "spring" }}
                                className="flex justify-center items-center w-full h-full gap-2 font-SansText400 tracking-widest"
                            >
                                <button 
                                    onClick={() => {setActiveTab("All"); setIsFilterOpen(false);}}
                                    className={`${activeTab === "All" ? "bg-lime-300 px-4 py-2 text-gray-800 shadow-sm" : "text-gray-600 hover:text-gray-800 px-2 py-1"} rounded-full transition-all duration-200`}
                                >
                                    ALL
                                </button>
                                <button
                                    onClick={() => {setActiveTab("Bookmark"); setIsFilterOpen(false);}}
                                    className={`${activeTab === "Bookmark" ? "bg-lime-300 px-4 py-2 text-gray-800 shadow-sm" : "text-gray-600 hover:text-gray-800 px-2 py-1"} rounded-full transition-all duration-200`}
                                >
                                    BOOKMARKS
                                </button>
                                <button
                                    onClick={() => {setActiveTab("Note"); setIsFilterOpen(false);}}
                                    className={`${activeTab === "Note" ? "bg-lime-300 px-4 py-2 text-gray-800 shadow-sm" : "text-gray-600 hover:text-gray-800 px-2 py-1"} rounded-full transition-all duration-200`}
                                >
                                    NOTES
                                </button>
                            </motion.div>
                        )}
                    </div>
                </div>

                <div className={`font-NanumMyeongjo  text-4xl text-center ${isError ? "text-red-900" : "text-black"}`}>
                    <motion.h1
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ duration: 1.5 }}
                        className="text-center"
                    >"{isError ? "The Query must be atleast 3 characters !" : Quote}"</motion.h1>
                </div>
                <div className="w-[95%] mx-auto flex justify-between items-center">
                    <Button text="HOME" handle={() => Navigate("/submit")} textColor="--primary-white"
                        IncMinWidth="118px" />
                    <Button 
                        text={query.trim() ? "SEARCH" : "SHOW ALL"} 
                        handle={query.trim() ? handleSearch : handleSearchAll} 
                        textColor="--primary-white" 
                    />
                </div>
            </div>
        </>
    );
}


================================================
FILE: frontend/src/page/SearchResultPage.tsx
================================================
import React, { useEffect, useRef, useState } from 'react';
import Cards from '../components/Cards';
import Button from '../components/Button';
import { useLocation, useNavigate } from 'react-router-dom';
import '../index.css';
import LoaderPillars from '../components/LoaderPillars';
import ToggleTabs from '../components/toggleTab';
import { deleteLink, deleteNote } from '../utils/apiClient';

// interface ProcessedResult {
//   title: string;
//   url: string;
//   content: string;
//   date: string;
//   ID: string;
// }

const SearchResponse: React.FC = () => {
  const location = useLocation();
  const responseData = location.state?.data || [];
  const query = location.state?.Query || "";
  const isSearchAll = location.state?.isSearchAll || false;
  const errorMessage = location.state?.error || null;
  const linksArray = location.state?.linksArray || [];
  const notesArray = location.state?.notesArray || [];

  const colors = [
    'bg-custom-orange',
    'bg-custom-light-violet',
    'bg-custom-lime',
    'bg-custom-hot-pink',

    'bg-custom-electric-blue',
    'bg-custom-marigold',
    'bg-custom-bright-purple',
    'bg-custom-neon-green',

    'bg-custom-bright-orange',
    'bg-custom-vivid-blue',
    'bg-custom-lime-yellow',
    'bg-custom-violet',

    'bg-custom-chartreuse',
    'bg-custom-light-pink',
    'bg-custom-electric-lime',
    'bg-custom-blue',

    'bg-custom-brownish-orange',
    'bg-custom-green',
    'bg-custom-bright-yellow',
    'bg-custom-yellow'
  ];

  const currentIndex = useRef(0);
  const getNextColor = () => {
    const color = colors[currentIndex.current];
    currentIndex.current = (currentIndex.current + 1) % colors.length;
    return color;
  };

  interface CardType {
    key: number;
    title: string;
    fullDescription: string;
    bgColor: string;
    RedirectUrl: string;
    date: string;
    ID: string;
    type: string;
    isSearchAll: boolean;
    activeTab: string;

  }

  const [Card, setCards] = useState<CardType[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [DeleteClicked, setDeleteClicked] = useState<boolean>(false);
  const [confirmDelete, setConfirmDelete] = useState<boolean>(false);
  const [DeleteSuccess, setDeleteSuccess] = useState<boolean>(false);
  const [filteredBrowserBookmarks, setFilteredBrowserBookmarks] = useState<Array<{ url: string, title: string }>>([]);
  const [activeTab, setActiveTab] = useState("All");
  const tabs = ["All", "Bookmark", "Note"];

  const allBookmarks: string[] = [];

  useEffect(()=>{
    console.log("The active tab is:", activeTab);
  },[activeTab])

  useEffect(() => {
    const getAllBookmarks = () => {
      if (!chrome.bookmarks) {
        console.error("chrome.bookmarks API is not available.");
        return;
      }

      // chrome.bookmarks.getTree((bookmarkTreeNodes) => {
      //     const allBookmarks: Array<{ url: string, title: string }> = [];

      //     const extractBookmarks = (nodes: chrome.bookmarks.BookmarkTreeNode[]) => {
      //         for (const node of nodes) {
      //             if (node.url) {
      //                 const url = node.url;
      //                 allBookmarks.push({
      //                     url: node.url,
      //                     title: node.title || url.split("/").pop() || url 
      //                 });
      //             }
      //             if (node.children) extractBookmarks(node.children);
      //         }
      //     };

      //     extractBookmarks(bookmarkTreeNodes);

      //     const newCards = allBookmarks.map((item, index) => ({
      //         key: Card.length + index + 1,
      //         title: item.title, 
      //         fullDescription: item.url,
      //         bgColor: randomColor()
      //     }));

      //     setCards(prev => [...prev, ...newCards]);


      // });

      if (responseData) {
        if (responseData.length === 0) {
          return;
        }
        console.log("The query is:", query);
        console.log("The responseData items:", responseData);
        const newCards = responseData.map((item: any, index: number) => ({
          key: Card.length + index + 1,
          title: item.title,
          fullDescription: (item.content === "" ? "No Description" : item.content),
          bgColor: getNextColor(),
          RedirectUrl: item.url,
          date: item.date ?
            new Date(item.date).toLocaleDateString("en-GB", {
              day: "2-digit",
              month: "long",
              year: "numeric",
            })

            : "No Date",
          ID: item.ID,
          type: item.type,
          isSearchAll: isSearchAll,
          activeTab: activeTab


        }

        ));
        console.log("The newCards after mapping:", newCards);
        setCards(newCards);
      }else if(linksArray && notesArray){
        console.log("The links array is:", linksArray);
        console.log("The notes array is:", notesArray);
        const newCards = [...linksArray, ...notesArray].map((item: any, index: number) => ({
          key: Card.length + index + 1,
          title: item.title,
          fullDescription: (item.content === "" ? "No Description" : item.content),
          bgColor: getNextColor(),
          RedirectUrl: item.url,
          date: item.date ?
            new Date(item.date).toLocaleDateString("en-GB", {
              day: "2-digit",
              month: "long",
              year: "numeric",
            })

            : "No Date",
          ID: item.ID,
          type: item.type,
          isSearchAll: isSearchAll,
          activeTab: activeTab
        }

        ));
        console.log("The newCards from linksArray/notesArray:", newCards);
        setCards(newCards);
      }

      if (!chrome.bookmarks || !query) {
        setFilteredBrowserBookmarks([]);
        return;
      }

      chrome.bookmarks.getTree((bookmarkTreeNodes) => {
        const matches: Array<{ url: string, title: string }> = [];
        const lowerQuery = query.toLowerCase();

        const extractAndFilter = (nodes: chrome.bookmarks.BookmarkTreeNode[]) => {
          const allBrowserBookmarks = nodes.map((node) => ({
            url: node.url,
            title: node.title || node.url && node.url.split("/").pop() || node.url
          }));
          console.log("All bookmarks from chrome: ", allBrowserBookmarks);
          for (const node of nodes) {
            if (node.url && (
              node.title.toLowerCase().includes(lowerQuery) ||
              node.url.toLowerCase().includes(lowerQuery)
            )) {
              console.log("the node is after checking  :", node)
              matches.push({
                url: node.url,
                title: node.title || node.url.split("/").pop() || node.url
              });
              console.log("now the matches are:", matches);
            }
            if (node.children) extractAndFilter(node.children);
          }
        };

        extractAndFilter(bookmarkTreeNodes);
        setFilteredBrowserBookmarks(matches);

      });

    };

    getAllBookmarks();
  }, allBookmarks);


  useEffect(() => {
    console.log("Filtered browser bookmarks: ", filteredBrowserBookmarks);
  }, [filteredBrowserBookmarks]);

  const handleDelete = async () => {
    setIsLoading(true);
    if (selectedIndex !== null) {
      const cardToDelete = Card[selectedIndex];
      console.log("=== DELETE DEBUG ===");
      console.log("selectedIndex:", selectedIndex);
      console.log("cardToDelete:", cardToDelete);
      console.log("cardToDelete.ID:", cardToDelete.ID);
      console.log("Card array:", Card);
      console.log("==================");
      
      const isNote = cardToDelete.type === "Note";
      
      try {
        if (isNote) {
          await deleteNote(cardToDelete.ID);
        } else {
          await deleteLink(cardToDelete.ID);
        }
        
        // Successfully deleted from backend, now remove from UI
        setCards(prevCards => prevCards.filter((_, index) => index !== selectedIndex));
        setSelectedIndex(null);
        setDeleteSuccess(true);
        setIsLoading(false);
        setConfirmDelete(true);
        
        console.log(`Successfully deleted ${isNote ? 'note' : 'bookmark'}:`, cardToDelete);
      } catch (error: any) {
        console.error("Delete failed:", error);
        setDeleteSuccess(false);
        setIsLoading(false);
        setConfirmDelete(true);
      }
    } else {
      setIsLoading(false);
    }
  }



  const Navigate = useNavigate();

  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);



  return (
    <div

      style={{ backgroundColor: responseData.length === 0 ? 'var(--primary-red)' : 'var(--primary-white)' }}

      className={`relative max-w-md  rounded-lg w-[420px] h-[500px] flex flex-col justify-center border border-black py-0 overflow-hidden`}>
      {Card.length === 0 ? (
        <div className='text-center px-6'>
          <p className='text-2xl black mb-3 pb-7 nyr-semibold'>
            {errorMessage ? 'Search Error' : 'Oops ! No items found'}
          </p>
          {errorMessage && (
            <p className='text-lg text-gray-700 mb-4 nyr'>
              {errorMessage}
            </p>
          )}
          {query && !errorMessage && (
            <p className='text-sm text-gray-600 nyr'>
              No results found for "{query}"
            </p>
          )}
        </div>
      ) : (<>
      
        {isSearchAll && selectedIndex === null && 
        <ToggleTabs 
        tabs={tabs}
        activeTab={activeTab}
        setActiveTab={setActiveTab}
        />

        }
      
      <div className={` 
        
        ${selectedIndex === null
          ? `overflow-y-scroll py-3 ${isSearchAll ? 'pt-[62px]' : ''} pb-[89px] px-3 `
          : 'overflow-y-scroll py-0 px-0 cursor-default'}
        [&::-webkit-scrollbar]:hidden w-[100%] h-[100%]`}>
        {selectedIndex === null
          ?
          Card.map((card, index) => (
            <Cards
              key={index}
              title={card.title}
              description={card.fullDescription}
              bgColor={card.bgColor}
              onClick={() => {
                setSelectedIndex(index);
                setConfirmDelete(false);
                setDeleteSuccess(false);
              }}
              isSelected={false}
              RedirectUrl={card.RedirectUrl}
              date={card.date}
              confirmDelete={confirmDelete}
              setDeleteClicked={setDeleteClicked}
              isSearchAll={isSearchAll && activeTab === "All"}
              type={card.type}
              activeTab={activeTab}
            />
          )

          )
          : (

            DeleteClicked ?
              <p className='nyr flex justify-center items-center bg-[var(--primary-red)] text-2xl text-center text-black
              w-[100%] h-[90%]'>Are you sure you want to delete this item?</p>
              :
              confirmDelete ?
                isLoading ?
                  <div className='flex justify-center items-center w-full h-[90%] bg-[var(--primary-red)]'>
                    <LoaderPillars />
                  </div>
                  :
                  DeleteSuccess ?
                    <p className='nyr flex justify-center items-center bg-[var(--primary-green)] text-2xl text-center text-black
            w-[100%] h-[90%]'>Item Deleted Successfully!</p> :
                    <p className='nyr flex justify-center items-center bg-[var(--primary-red)] text-2xl text-center text-black  
            w-[100%] h-[90%]'>Failed to delete item!</p>
                :

                <Cards
                  title={Card[selectedIndex].title}
                  description={Card[selectedIndex].fullDescription}
                  bgColor={Card[selectedIndex].bgColor}
                  onClick={() => null}
                  isSelected={true}
                  RedirectUrl={Card[selectedIndex].RedirectUrl}
                  date={Card[selectedIndex].date}
                  confirmDelete={confirmDelete}
                  setDeleteClicked={setDeleteClicked}
                  isSearchAll={isSearchAll && activeTab === "All"}
                  type={Card[selectedIndex].type}
                  activeTab={activeTab}
                />



          )}
          { filteredBrowserBookmarks.length > 0 && selectedIndex === null && activeTab === "All" && <div>
          {filteredBrowserBookmarks.length > 0  && selectedIndex === null && <h1 className='text-center text-[20px] black mt-2 pb-2 nyr-semibold font-medium'>Browser Bookmarks</h1> }
          {filteredBrowserBookmarks.length > 0  && selectedIndex === null && filteredBrowserBookmarks.map((item, index) => (
            <Cards
              key={index}
              title={item.title}
              description={"No description, link: " + item.url}
              bgColor={getNextColor()}
              onClick={() => window.open(item.url)}
              isSelected={false}
              RedirectUrl={item.url}
              date={""}
              confirmDelete={confirmDelete}
              setDeleteClicked={setDeleteClicked}
              isSearchAll={isSearchAll && activeTab === "All"}
              type={""}
              activeTab={activeTab}
            />
          ))}
        </div>}
      </div>
        
      </>

      )}


      <div className="absolute bottom-0 rounded-b-lg w-full min-h-[90px] flex items-center justify-between px-10 bg-white border-t border-black">
        <Button
          text={DeleteClicked ? "NO" : 'BACK'}
          handle={() => {
            if (DeleteClicked) {
              setDeleteClicked(false);
            } else {

              if (selectedIndex === null) Navigate("/search");
              else setSelectedIndex(null);
              setConfirmDelete(false);
              setDeleteSuccess(false);
            }
          }}
          textColor='--primary-white'
        />
        <Button
          text={DeleteClicked ? "YES" : 'HOME'}
          handle={() => {
            if (DeleteClicked) {
              handleDelete();
              setDeleteClicked(false);
              setConfirmDelete(true);
            } else {
              Navigate("/submit");
            }
          }}
          textColor='--primary-white'
        />
      </div>
    </div>
  );
};

export default SearchResponse;


================================================
FILE: frontend/src/page/SummarizePage.tsx
================================================
import { motion } from "framer-motion";
import ClickSpark from "../components/ClickSpark";
import { useNavigate } from "react-router-dom";
import Button from "../components/Button";
import { useEffect, useState, useRef } from "react";
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

const AppleIntelligenceLoader = () => {
  const [isLoading, setIsLoading] = useState(true);
  const Navigate = useNavigate();
  const [pageContent, setPageContent] = useState<string>("");
  const [error, setError] = useState<string>("");
  const hasInitiatedRequest = useRef(false);

  useEffect(() => {
    // Prevent multiple requests if already initiated
    if (hasInitiatedRequest.current) {
      return;
    }
    
    hasInitiatedRequest.current = true;
    
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const tabId = tabs[0]?.id;
      if (!tabId) {
        console.log("No tab found");
        setIsLoading(false);
        return;
      }
      chrome.tabs.sendMessage(
        tabId,
        { action: "extractPageContent" },
        (response) => {
          if (response && response.content) {
            setPageContent(response.content);
            setIsLoading(false);
          } else if (response && response.error) {
            console.log("Error from content script:", response.error);
            if (response.error === 'RATE_LIMIT_EXCEEDED') {
              setError("You have used 5 free summarizations for today. Please try again tomorrow!");
            } else {
              setError("Failed to generate summary. Please try again later.");
            }
            setIsLoading(false);
          } else {
            console.log("No response from content script");
            setError("Failed to generate summary. Please try again later.");
            setIsLoading(false);
          }
        }
      );
    });
  }, []);

  return (
    <ClickSpark
      sparkColor='#fff'
      sparkSize={10}
      sparkRadius={15}
      sparkCount={8}
      duration={400}
    >
      <motion.div
        className="w-[420px] h-[500px] bg-yellow flex items-center justify-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.9, ease: "ease" }
        }
      >


        <div className="relative w-[420px] h-[500px]">
          <div className="relative bg-white w-full h-full  top-0">
            <div className={`text-center space-y-4 absolute z-50 w-full h-full flex flex-col ${isLoading || error ? 'justify-center items-center' : 'justify-start items-start'}`}>
              {isLoading ? (<> <h2 className="text-4xl  text-black font-NanumMyeongjo">
                Summarizing...
              </h2>
                <p className="text-black max-w-xs">
                  Processing your request with advanced AI capabilities...
                </p>
              </>) : error ? (<>
                <h2 className="text-3xl text-black font-NanumMyeongjo mb-4">
                  Oops!
                </h2>
                <p className="text-black max-w-sm text-center px-4 leading-relaxed">
                  {error}
                </p>
              </>) : (
                <>
                  <div className="overflow-y-scroll h-[80%] mx-auto w-[95%] rounded-3xl">
                    <p className="text-black overflow-y-scroll">
                      <div className="text-left font-NanumMyeongjo p-6 rounded-2xl shadow-lg markdown-content">
                        
                        <ReactMarkdown
                          remarkPlugins={[remarkGfm]}
                          components={{
                            h1: ({ node, ...props }) => <h1 className="text-3xl lg:text-4xl font-extrabold mt-6 mb-4 text-black" style={{ fontSize: '2rem', minHeight: '15px' }} {...props} />,
                            h2: ({ node, ...props }) => <h2 className="text-2xl lg:text-3xl font-bold mt-6 mb-4 border-b pb-2 border-slate-200 text-black" style={{ fontSize: '1.5rem', minHeight: '15px' }} {...props} />,
                            h3: ({ node, ...props }) => <h3 className="text-xl lg:text-2xl font-semibold mt-5 mb-3 text-black" style={{ fontSize: '1.25rem', minHeight: '15px' }} {...props} />,

                            p: ({ node, ...props }) => <p className="mb-4 leading-relaxed text-black" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,
                            ul: ({ node, ...props }) => <ul className="list-disc list-outside ml-5 mb-4 space-y-2 text-black" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,
                            ol: ({ node, ...props }) => <ol className="list-decimal list-outside ml-5 mb-4 space-y-2 text-black" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,
                            li: ({ node, ...props }) => <li className="mb-1 text-black" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,

                            a: ({ node, ...props }) => <a className="text-black underline decoration-black/30 hover:decoration-black transition" target="_blank" rel="noopener noreferrer" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,

                            blockquote: ({ node, ...props }) => (
                              <blockquote className="border-l-4 border-black pl-4 italic text-black my-6 bg-gray-100 py-2 rounded-r-lg" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />
                            ),

                            code: ({ node, className, children, ...props }) => {
                              const isInline = !(className && /^language-/.test(className));
                              if (!isInline) {
                                return (
                                  <code className={`${className} text-sm font-mono text-black`} style={{ fontSize: '15px', minHeight: '15px' }} {...props}>
                                    {children}
                                  </code>
                                );
                              }
                              return (
                                <code className="bg-gray-200 rounded-md px-1.5 py-1 text-sm font-mono text-black" style={{ fontSize: '12px', minHeight: '15px' }} {...props}>
                                  {children}
                                </code>
                              );
                            },

                            pre: ({ node, ...props }) => (
                              <pre className="bg-gray-800 rounded-md p-4 my-6 overflow-x-auto" style={{ color: 'black', fontSize: '15px', minHeight: '15px' }} {...props} />
                            ),

                            strong: ({ node, ...props }) => <strong className="font-semibold text-black" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,
                            em: ({ node, ...props }) => <em className="italic text-black" style={{ fontSize: '15px', minHeight: '15px' }} {...props} />,
                            hr: ({ node, ...props }) => <hr className="my-8 border-black" {...props} />,
                          }}
                        >
                          {pageContent}
                        </ReactMarkdown>
                      </div>
                    </p>
                  </div>
                </>
              )
              }
            </div>
            <div className="absolute bottom-5 p-4 z-[100000] w-full flex justify-center">
              <div className="mx-auto">
                <Button text={isLoading ? `CANCEL` : error ? 'CLOSE' : 'HOME'} handle={() => Navigate("/submit")} textColor="--primary-white" />
              </div>

            </div>
          </div>
          {(
            <div
              className="absolute inset-0 blur-xl opacity-90 animate-pulse "
              style={{
                background: 'linear-gradient(45deg, #8B5CF6, #EC4899, #F97316, #EAB308, #10B981, #3B82F6)',
                backgroundSize: '200% 200%',
                animation: 'gradientShift 3s ease-in-out infinite'
              }}
            />
          )}
        </div>
        <style>{`
        @keyframes gradientShift {
          0%, 100% {
            background-position: 0% 50%;
          }
          50% {
            background-position: 100% 50%;
          }
        }
        
        /* Hide scrollbar for webkit browsers */
        .overflow-y-scroll::-webkit-scrollbar {
          display: none;
        }
        
        /* Hide scrollbar for IE, Edge and Firefox */
        .overflow-y-scroll {
          -ms-overflow-style: none;  /* IE and Edge */
          scrollbar-width: none;  /* Firefox */
        }
      `}</style>

      </motion.div>
    </ClickSpark>
  );
};

export default AppleIntelligenceLoader;


================================================
FILE: frontend/src/utils/api.ts
================================================
// Simple API client based on OauthImplementation.md

const SUPABASE_URL = "https://dzftiemmhvmtrlooukqd.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR6ZnRpZW1taHZtdHJsb291a3FkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg2MTQ5NjEsImV4cCI6MjA1NDE5MDk2MX0.pFPUNjrL52biBlNmwcSwJRxhQ7mx1Elqnh_6OOVABM4";
const API_BASE_URL = "http://127.0.0.1:8000";

// This is the core function that handles API calls and token refreshing.
export async function fetchWithAutoRefresh(url: string, options: RequestInit = {}): Promise<Response> {
  let tokens = await chrome.storage.local.get(["access_token", "refresh_token"]);

  if (!tokens.access_token) {
    console.error("❌ User not authenticated. No access token found.");
    throw new Error("User not authenticated.");
  }

  // Set the authorization header
    options.headers = {
      ...options.headers,
      'Authorization': `Bearer ${tokens.access_token}`,
      'Content-Type': 'application/json'
    } as HeadersInit;
    
    console.log('📡 FRONTEND: Preparing API request');
    console.log(`   ├─ URL: ${API_BASE_URL}${url}`);
    console.log(`   ├─ Method: ${options.method || 'GET'}`);
    console.log(`   ├─ Access token present: ${!!tokens.access_token}`);
    console.log(`   ├─ Refresh token present: ${!!tokens.refresh_token}`);
    console.log(`   ├─ Authorization header: ${(options.headers as any)['Authorization'] ? 'Bearer ' + (options.headers as any)['Authorization'].toString().substring(7, 27) + '...' : 'Missing'}`);
    console.log(`   └─ All headers:`, Object.keys(options.headers));

  // First attempt
  let response = await fetch(`${API_BASE_URL}${url}`, options);

  // If the token is expired (401), try to refresh it
  if (response.status === 401 && tokens.refresh_token) {
    console.log("🔄 Access token expired. Refreshing tokens...");
    console.log(`🔑 Using refresh token: ${tokens.refresh_token.substring(0, 20)}...`);

    const refreshResponse = await fetch(`${SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`, {
      method: 'POST',
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        refresh_token: tokens.refresh_token
      }),
    });

    if (!refreshResponse.ok) {
        const errorData = await refreshResponse.text();
        console.error("❌ Failed to refresh token. Response:", refreshResponse.status, errorData);
        // Clear tokens and force re-login
        await chrome.storage.local.remove(["access_token", "refresh_token"]);
        throw new Error("Could not refresh session. Please log in again.");
    }
    
    const newTokens = await refreshResponse.json();
    console.log("✅ New tokens received:");
    console.log(`   - Access Token: ${newTokens.access_token ? newTokens.access_token.substring(0, 20) + '...' : 'Not found'}`);
    console.log(`   - Refresh Token: ${newTokens.refresh_token ? newTokens.refresh_token.substring(0, 20) + '...' : 'Not found'}`);
    
    // Save both the new access token and refresh token
    await chrome.storage.local.set({
      access_token: newTokens.access_token,
      refresh_token: newTokens.refresh_token || tokens.refresh_token // Use new refresh token if provided, otherwise keep the old one
    });

    console.log("💾 New tokens saved to storage.");
    console.log("🔄 Retrying original request with new access token...");

    // Retry the original request with the new access token
    (options.headers as any)['Authorization'] = `Bearer ${newTokens.access_token}`;
    response = await fetch(`${API_BASE_URL}${url}`, options);
    
    if (response.ok) {
      console.log("✅ Original request succeeded after token refresh.");
    } else {
      console.log(`❌ Original request still failed after token refresh. Status: ${response.status}`);
    }
  }

  return response;
}

// Check authentication status using the backend endpoint
export async function checkAuthStatus() {
    const tokens = await chrome.storage.local.get(["access_token", "refresh_token"]);
    
    if (!tokens.access_token) {
        throw new Error("No access token found");
    }

    const response = await fetch(`${API_BASE_URL}/auth/status`, {
        method: 'GET',
        credentials: 'include',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${tokens.access_token}`
        }
    });

    if (!response.ok) {
        throw new Error(`Auth status check failed: ${response.status}`);
    }
    
    return response.json();
}


// Simple logout function
export async function logout() {
    await chrome.storage.local.remove(['access_token', 'refresh_token']);
}



================================================
FILE: frontend/src/utils/apiClient.ts
================================================
// API client for making authenticated requests to the backend
// Uses cookie-based authentication handled by backend middleware

import { logout } from './api';

const getApiBaseUrl = (): string => {
  // Always use the backend API URL for API calls
  const baseUrl = import.meta.env.VITE_BACKEND_URL;
  return baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
};

// Enhanced error response interface matching backend error format
interface ApiError {
  detail: string;
  error_type?: string;
  status_code?: number;
}


/**
 * Make authenticated requests - backend handles token validation and refresh automatically
 */
export const makeRequest = async <T = any>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> => {
  const baseUrl = getApiBaseUrl();
  const url = `${baseUrl}${endpoint}`;
  
  console.log(`🌐 API CLIENT: Initiating ${options.method || 'GET'} request`);
  console.log(`   ├─ Endpoint: ${endpoint}`);
  console.log(`   ├─ Full URL: ${url}`);
  console.log(`   ├─ Base URL: ${baseUrl}`);
  console.log(`   └─ Method: ${options.method || 'GET'}`);
  
  // Get tokens from chrome.storage.local
  const tokens = await chrome.storage.local.get(["access_token", "refresh_token"]);
  console.log(`   ├─ Access token present: ${!!tokens.access_token}`);
  console.log(`   └─ Refresh token present: ${!!tokens.refresh_token}`);
  
  const defaultOptions: RequestInit = {
    credentials: 'same-origin',
    headers: {
      'Content-Type': 'application/json',
      ...(tokens.access_token && { 'Authorization': `Bearer ${tokens.access_token}` }),
      ...options.headers,
    },
    ...options,
  };

  console.log(`🔧 API CLIENT: Request configuration`);
  console.log(`   ├─ Credentials: ${defaultOptions.credentials}`);
  console.log(`   ├─ Headers: ${JSON.stringify(defaultOptions.headers)}`);
  console.log(`   ├─ Body present: ${!!defaultOptions.body}`);
  console.log(`   └─ Body length: ${defaultOptions.body ? String(defaultOptions.body).length : 0} chars`);

  try {
    console.log(`📡 API CLIENT: Sending request to backend`);
    const startTime = performance.now();
    
    const response = await fetch(url, defaultOptions);
    
    const endTime = performance.now();
    const duration = Math.round(endTime - startTime);
    
    console.log(`📨 API CLIENT: Response received from backend`);
    console.log(`   ├─ Status: ${response.status} ${response.statusText}`);
    console.log(`   ├─ Response time: ${duration}ms`);
    console.log(`   ├─ Content-Type: ${response.headers.get('content-type') || 'Unknown'}`);
    console.log(`   └─ Headers: ${JSON.stringify(Array.from(response.headers.entries()))}`);
    
    // Backend middleware automatically handles:
    // - Token validation
    // - Token refresh when needed
    // - Setting new cookies in response headers
    // - User authentication state
    
    if (!response.ok) {
      console.error(`❌ API CLIENT: Request failed with status ${response.status}`);
      
      // Handle 401 Unauthorized responses by automatically logging out the user
      if (response.status === 401) {
        console.warn(`🚫 API CLIENT: Unauthorized response (401) - triggering automatic logout`);
        
        try {
          // Clear all authentication data and cookies
          await logout();
          console.log(`🔄 API CLIENT: Logout completed, redirecting to auth page`);
          
          // Redirect to auth page for re-authentication
          if (typeof window !== 'undefined') {
            window.location.href = '/auth';
          }
          
          // Throw a specific error for 401 responses
          throw new Error('Session expired. Please log in again.');
        } catch (logoutError) {
          console.error(`💥 API CLIENT: Logout failed during 401 handling:`, logoutError);
          // Still redirect to auth page even if logout fails
          if (typeof window !== 'undefined') {
            window.location.href = '/auth';
          }
          throw new Error('Authentication failed. Please log in again.');
        }
      }
      
      let errorData: ApiError;
      try {
        errorData = await response.json();
        console.error(`   ├─ Error detail: ${errorData.detail}`);
        console.error(`   ├─ Error type: ${errorData.error_type || 'Unknown'}`);
        console.error(`   └─ Status code: ${errorData.status_code || response.status}`);
      } catch (jsonError) {
        console.error(`   ├─ Could not parse error JSON: ${jsonError}`);
        errorData = {
          detail: `HTTP ${response.status}: ${response.statusText}`,
          status_code: response.status
        };
        console.error(`   └─ Using fallback error: ${errorData.detail}`);
      }
      
      const error = new Error(errorData.detail || 'Request failed');
      (error as any).status = response.status;
      (error as any).errorType = errorData.error_type;
      (error as any).statusCode = response.status;
      
      console.error(`💥 API CLIENT: Throwing error for failed request`);
      throw error;
    }
    
    // Try to parse JSON response
    const contentType = response.headers.get('content-type');
    console.log(`📋 API CLIENT: Processing response data`);
    
    if (contentType?.includes('application/json')) {
      console.log(`   ├─ Parsing JSON response`);
      const jsonData = await response.json();
      console.log(`   ├─ JSON keys: ${typeof jsonData === 'object' ? Object.keys(jsonData) : 'N/A'}`);
      console.log(`   └─ Response size: ${JSON.stringify(jsonData).length} chars`);
      console.log(`✅ API CLIENT: Request completed successfully`);
      return jsonData;
    }
    
    // Return response text for non-JSON responses
    console.log(`   ├─ Parsing text response`);
    const textData = await response.text();
    console.log(`   ├─ Text length: ${textData.length} chars`);
    console.log(`   └─ Text preview: ${textData.substring(0, 100)}...`);
    console.log(`✅ API CLIENT: Request completed successfully`);
    return textData as T;
  } catch (error: any) {
    console.error(`💥 API CLIENT: Request failed for ${endpoint}`);
    console.error(`   ├─ Error type: ${error.constructor.name}`);
    console.error(`   ├─ Error message: ${error.message}`);
    console.error(`   ├─ Status: ${error.status || 'Unknown'}`);
    console.error(`   └─ Error type: ${error.errorType || 'Unknown'}`);
    console.error('Full error:', error);
    throw error;
  }
};

// Convenience methods for different HTTP verbs
export const api = {
  get: <T = any>(endpoint: string, params?: Record<string, any>) => {
    const url = params ? `${endpoint}?${new URLSearchParams(params)}` : endpoint;
    return makeRequest<T>(url, { method: 'GET' });
  },
  
  post: <T = any>(endpoint: string, data?: any) => 
    makeRequest<T>(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    }),
  
  put: <T = any>(endpoint: string, data?: any) => 
    makeRequest<T>(endpoint, {
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    }),
  
  delete: <T = any>(endpoint: string) => 
    makeRequest<T>(endpoint, { method: 'DELETE' }),
  
  patch: <T = any>(endpoint: string, data?: any) => 
    makeRequest<T>(endpoint, {
      method: 'PATCH',
      body: data ? JSON.stringify(data) : undefined,
    }),
};


// Additional API methods that were previously in background.js
export const submitLink = async (data: any) => {
  console.log('📤 API CLIENT: Submitting link data');
  return api.post('/links/save', data);
};

export const saveNotes = async (data: { title: string; note: string }) => {
  console.log('📝 API CLIENT: Saving notes data');
  return api.post('/notes/', data);
};

export const searchAll = async () => {
  console.log('🔍 API CLIENT: Fetching all links and notes');
  const [linksData, notesData] = await Promise.all([
    api.get('/links/get'),
    api.get('/notes/')
  ]);
  return { links: linksData, notes: notesData };
};

export const searchLinks = async (query: string, type?: string) => {
  console.log('🔍 API CLIENT: Searching links');
  const requestBody: any = { query };
  if (type && type !== "All") {
    requestBody.filter = { type: { $eq: type } };
  }
  return api.post('/links/search', requestBody);
};

export const deleteLink = async (docId: string) => {
  console.log('🗑️ API CLIENT: Deleting link');
  return api.delete(`/links/delete?doc_id_pincone=${encodeURIComponent(docId)}`);
};

export const deleteNote = async (docId: string) => {
  console.log('🗑️ API CLIENT: Deleting note');
  return api.delete(`/notes/${encodeURIComponent(docId)}`);
};

export const generateSummary = async (content: string) => {
  console.log('📄 API CLIENT: Generating summary');
  return api.post('/summary/generate', { content });
};

export const getQuotes = async () => {
  console.log('💬 API CLIENT: Fetching quotes');
  return api.get('/quotes/');
};

// Export the main client
export default api;



================================================
FILE: frontend/src/utils/spaceUtils.ts
================================================
/**
 * Utility functions for handling space patterns in notes
 */

/**
 * Remove space pattern from text for clean display
 * @param text - The text to clean
 * @returns Text with space pattern removed
 * 
 * Examples:
 * removeSpacePattern("This is about #books: machine learning") -> "This is about machine learning"
 * removeSpacePattern("#songs: my favorite music") -> "my favorite music"
 */
export function removeSpacePattern(text: string | null | undefined): string {
  if (!text || typeof text !== 'string') {
    return text || '';
  }

  // Pattern to match #spacename: (same as backend)
  const pattern = /\s*#[a-zA-Z0-9_-]+:\s*/g;
  
  try {
    const cleanedText = text.replace(pattern, '').trim();
    return cleanedText || text;
  } catch (error) {
    console.error('Error removing space pattern from text:', error);
    return text;
  }
}

/**
 * Extract space name from text using the pattern #spacename:
 * @param text - The text to search for space pattern
 * @returns The extracted space name or null if no pattern found
 */
export function extractSpaceFromText(text: string | null | undefined): string | null {
  if (!text || typeof text !== 'string') {
    return null;
  }

  // Pattern to match #spacename: where spacename can contain letters, numbers, underscores, hyphens
  const pattern = /#([a-zA-Z0-9_-]+):/;
  
  try {
    const match = text.match(pattern);
    if (match && match[1]) {
      const spaceName = match[1].toLowerCase().trim();
      // Validate space name (basic validation)
      if (spaceName.length > 0 && spaceName.length <= 50) {
        return spaceName;
      }
    }
    return null;
  } catch (error) {
    console.error('Error extracting space from text:', error);
    return null;
  }
} 



