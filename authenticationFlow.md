Chrome Extension + Supabase + FastAPI Authentication Flow
Part A: Complete Authentication Flow (Conceptual & Visual)
The login begins when the user clicks "Login" in the extension UI. The extension’s JavaScript code calls chrome.identity.launchWebAuthFlow with a Supabase OAuth URL, including a redirect URI generated by chrome.identity.getRedirectURL(). This opens a browser window to Supabase’s Auth service (showing the Google sign-in screen). The user signs in with Google on that screen. Supabase then issues a JWT-based access token and a refresh token and redirects the browser back to the extension’s callback URI (https://<EXTENSION_ID>.chromiumapp.org/...) with the tokens in the URL fragment (#access_token=...&refresh_token=...). The extension’s callback page (an HTML/JS file in the extension) receives this URL. The extension’s JS code parses out the access_token and refresh_token from the fragment and securely stores them in chrome.storage.local
developer.chrome.com
. At this point the backend (FastAPI) has not yet been involved. Later, when the extension needs protected data, its JavaScript makes an HTTP request to the custom Python backend (e.g. GET /api/user/profile) including the access token in an Authorization: Bearer <token> header. Upon receiving a request, the FastAPI backend uses a JWT library (e.g. PyJWT) to decode and verify the token signature (using the Supabase JWT secret or JWKS
supabase.com
). If the token is valid and unexpired, the backend returns the requested data. If the token is missing or invalid/expired, the backend returns a 401 Unauthorized. Crucially, the backend is completely stateless about authentication – on each request it simply verifies the provided JWT and never manages sessions or refresh tokens. The sequence is:
User → Extension (click Login): Extension JS calls launchWebAuthFlow (backend idle).
Extension → Supabase Auth: Browser opens Supabase/Google login (backend idle).
User signs in on Supabase (backend idle).
Supabase → Extension Redirect: After login, Supabase redirects to https://<EXTENSION_ID>.chromiumapp.org/ with #access_token=…&refresh_token=….
Extension Callback: Extension extracts access_token and refresh_token, stores them via chrome.storage.local.set()
developer.chrome.com
.
Extension → Backend (API call): Extension sends Authorization: Bearer <access_token> in request to backend.
Backend verifies token: Backend decodes JWT (PyJWT with Supabase secret/JWKS)
dev.to
supabase.com
. If valid, returns data; if expired, returns 401.
Here is an ASCII sequence diagram of the flow (arrows show direction of requests/responses):
pgsql
Copy
Edit
User (Chrome Extension UI)
    |
    | [Click "Login"]
    v
Chrome Extension JS  --(launchWebAuthFlow to OAuth URL)-->  Supabase Auth (Google login page)
    |
    |  [User signs in on Supabase]
    v
Supabase Auth  --(redirect with tokens)-->  Chrome Extension (callback URL: https://<EXT_ID>.chromiumapp.org/?access_token=...&refresh_token=...)
    |
    |  [Extension extracts tokens, stores them]
    v
Chrome Extension JS --(fetch /api/profile with Authorization: Bearer <access_token>)-->  Python Backend
                                                         |
                                                         v
                                                 Backend verifies JWT and returns data
Part B: Prerequisites and Initial Setup
Chrome Extension Setup (manifest.json)
Permissions: At minimum include "identity" and "storage" in permissions. The identity permission lets you use chrome.identity.launchWebAuthFlow and chrome.identity.getRedirectURL(), and storage lets you persist tokens in chrome.storage.local
developer.chrome.com
. You may also include any host permissions (e.g. your API endpoint URL) as needed.
Manifest key: For development (unpacked extension), Chrome generates a random ID by default. To have a stable extension ID (needed for redirect URIs and testing), add a key to your manifest. This key is the public key of your extension. You can obtain it by zipping your extension, uploading to the Chrome Developer Dashboard (without publishing), and copying the public key shown there. Paste it into "key": "<LONG_BASE64_KEY>" in manifest.json
developer.chrome.com
stackoverflow.com
. This ensures the extension ID remains the same in dev and production. For example:
json
Copy
Edit
{
  "manifest_version": 3,
  "name": "MyExtension",
  "version": "1.0",
  "permissions": ["identity", "storage"],
  // Optional if using Chrome-managed OAuth2; not required for launchWebAuthFlow:
  "oauth2": {
    "client_id": "YOUR_CLIENT_ID.apps.googleusercontent.com",
    "scopes": ["openid", "email", "profile"]
  },
  "key": "<YOUR_EXTENSION_PUBLIC_KEY>",
  // ...
}
The oauth2 block (shown above) is only needed if you plan to use Chrome’s built-in identity methods (e.g. chrome.identity.getAuthToken for Google). For a custom flow with Supabase OAuth, you primarily use launchWebAuthFlow and build the URL yourself
developer.chrome.com
. However, including the key is important for a consistent ID
developer.chrome.com
stackoverflow.com
.
Getting the Extension ID: Once you have a stable key, your extension’s ID will be fixed. During development you can find the ID on chrome://extensions/ or via chrome.runtime.id in code. You will use this ID in the redirect URI. Chrome’s redirect URLs have the form https://<EXTENSION_ID>.chromiumapp.org/. You should also use chrome.identity.getRedirectURL() in your code to generate the exact callback URL (this will yield something like https://<EXT_ID>.chromiumapp.org/_generated_background_page.html).
Supabase Project Configuration
Enable Google OAuth: In your Supabase project dashboard, go to Authentication → Settings → External OAuth Providers, and enable Google. Set the Google Client ID and Client Secret you obtained from Google Cloud Console (see below) in the Supabase UI for the Google provider.
Redirect URLs: Supabase needs to know the authorized redirect URI(s). In Authentication → Settings → URL Configuration, add the redirect URL for your extension. It should be https://<YOUR_EXTENSION_ID>.chromiumapp.org/ (you may include a wildcard or specific path). If you have multiple environments (unpacked dev vs store build), you might add multiple URIs. Note: in development mode (unpacked), Chrome generates a different redirect URL than the published extension, so be sure to add each variant
pustelto.com
. For example, the Pustelnik guide notes:
“Go to Authentication → URL Configuration and add both redirect URLs (for Chrome and Firefox). Please note that unbundled extensions during dev will have different redirect URLs than the production build.”
pustelto.com
.
Google Cloud Setup: In the Google Cloud Console, configure your OAuth consent screen and create OAuth credentials:
Consent Screen: Under “OAuth consent screen”, add your Supabase domain (<PROJECT_REF>.supabase.co) to the authorized domains.
Credentials: Create an OAuth 2.0 Client ID of type “Chrome App” or “Web application”. For development, it’s often easiest to use a Web application client and manually set the redirect URI (as the StackOverflow answer suggests
stackoverflow.com
). In the credentials, set Authorized redirect URIs to https://<EXTENSION_ID>.chromiumapp.org (no trailing slash). If you use “Chrome App” type, note that by default Google expects https://<EXTENSION_ID>.chromiumapp.org/ without a slash in the Google settings
stackoverflow.com
. A helpful tip: if you test locally, ensure you include the key so that your extension ID matches the one in your Google credentials
stackoverflow.com
.
After creating the client ID & secret, copy them into the Supabase dashboard as instructed. (Supabase’s docs say: “add these to the Google Auth Provider section of the Supabase Dashboard”
supabase.com
.)
Supabase Keys and URLs: In your Supabase dashboard (Settings → API), locate:
Project URL (e.g. https://<PROJECT_REF>.supabase.co) – use this as SUPABASE_URL.
Anon public API key – use as SUPABASE_ANON_KEY in your frontend calls.
JWT Secret – this is the symmetric key for HS256 tokens (legacy) or signing key identifier. Copy this if you plan to verify tokens locally. If your project uses RS256 (as is default with JWT signing keys), you can fetch the public keys from the JWKS endpoint at https://<PROJECT_REF>.supabase.co/auth/v1/.well-known/jwks.json 
supabase.com
 to verify tokens. Keep these credentials safe.
Part C: Frontend Implementation (React in Extension)
Below are example code snippets (in JavaScript/React) for each part of the extension logic.
Initiating Authentication: Build the Supabase auth URL and call chrome.identity.launchWebAuthFlow. For Google, you can either use Supabase’s /auth/v1/authorize endpoint or directly use the Supabase client. Here’s a plain JS example using launchWebAuthFlow and Supabase’s REST endpoint:
js
Copy
Edit
const SUPABASE_URL = "<your-supabase-url>";      // e.g. https://xyz.supabase.co
const CLIENT_ID = "<your-google-client-id>";    // if needed for Google-specific flows

async function loginWithSupabase() {
  const redirectUri = chrome.identity.getRedirectURL();  // e.g. https://<EXT_ID>.chromiumapp.org/
  // Construct the Supabase OAuth URL (Google provider):
  const authUrl = `${SUPABASE_URL}/auth/v1/authorize?provider=google&redirect_to=${encodeURIComponent(redirectUri)}`;
  
  // Launch the OAuth flow:
  chrome.identity.launchWebAuthFlow({ url: authUrl, interactive: true }, (redirectedTo) => {
    if (chrome.runtime.lastError || !redirectedTo) {
      console.error("Auth flow error:", chrome.runtime.lastError);
      return;
    }
    // The redirect URL contains the access and refresh tokens in the fragment
    const urlFragment = new URL(redirectedTo).hash.substring(1); // drop the '#'
    const params = new URLSearchParams(urlFragment);
    const accessToken = params.get('access_token');
    const refreshToken = params.get('refresh_token');
    if (accessToken && refreshToken) {
      // Store tokens securely
      chrome.storage.local.set({ access_token: accessToken, refresh_token: refreshToken });
    } else {
      console.error("No tokens received");
    }
  });
}
This uses chrome.identity.getRedirectURL() to automatically generate the correct URI for your extension
github.com
stackoverflow.com
. The Supabase response will include access_token and refresh_token in the URL hash (fragment), which we parse via URLSearchParams.
Handling the Callback: The above launchWebAuthFlow callback receives the redirectedTo URL. As shown, we parse redirectedTo.hash to extract tokens. Alternatively, if your extension uses a dedicated HTML page for the redirect, that page’s script can similarly read window.location.hash. Either way, ensure you remove the leading # when parsing. For example:
js
Copy
Edit
const url = new URL(redirectedTo);
const fragment = url.hash.replace('#', '');
const query = new URLSearchParams(fragment);
const accessToken = query.get('access_token');
const refreshToken = query.get('refresh_token');
Secure Token Storage: Store tokens in chrome.storage.local. This is asynchronous. For instance:
js
Copy
Edit
await chrome.storage.local.set({ access_token: accessToken, refresh_token: refreshToken });
To retrieve them later, use:
js
Copy
Edit
const result = await chrome.storage.local.get(["access_token", "refresh_token"]);
const storedAccessToken = result.access_token;
const storedRefreshToken = result.refresh_token;
console.log("Stored tokens:", storedAccessToken, storedRefreshToken);
As shown in Chrome’s docs:
chrome.storage.local.set({ key: value }).then(...) and chrome.storage.local.get(["key"]).then(...) are used for storing and retrieving
developer.chrome.com
.
Making Authenticated API Calls: When calling your backend API, include the access token in the Authorization header. For example, using fetch:
js
Copy
Edit
async function callProtectedApi() {
  const { access_token } = await chrome.storage.local.get("access_token");
  if (!access_token) throw new Error("No access token available");

  const response = await fetch("https://api.yourbackend.com/api/user/profile", {
    headers: { 
      "Authorization": `Bearer ${access_token}`
    }
  });
  if (response.status === 401) {
    throw new Error("Unauthorized");
  }
  return response.json();
}
This demonstrates retrieving the stored token and adding it to the request headers. The backend will then decode/verify this JWT as shown next.
Part D: Backend Implementation (FastAPI)
Below is sample FastAPI code illustrating a protected endpoint and JWT verification. Install PyJWT first (pip install PyJWT). We assume HS256 with the Supabase secret; if using RS256, you would fetch and use the JWKS as noted above.
python
Copy
Edit
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt

app = FastAPI()
oauth2_scheme = HTTPBearer(auto_error=False)

# Use your Supabase project's JWT secret here:
SUPABASE_JWT_SECRET = "your-supabase-jwt-secret"

# Middleware/Dependency to verify JWT
def verify_token(
    credentials: HTTPAuthorizationCredentials = Depends(oauth2_scheme)
):
    if credentials is None or not credentials.scheme.lower() == "bearer":
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Authentication required")
    token = credentials.credentials
    try:
        payload = jwt.decode(
            token,
            SUPABASE_JWT_SECRET,
            algorithms=["HS256"],      # or ["RS256"] if using public keys
            audience="authenticated"   # Supabase tokens use audience "authenticated"
        )
    except jwt.PyJWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired token")
    return payload

@app.get("/api/user/profile")
async def get_profile(user=Depends(verify_token)):
    # At this point, 'user' is the decoded JWT payload (a dict with e.g. 'email', 'sub', etc.)
    return {"email": user.get("email"), "message": "Token valid"}

Key points:
We use HTTPBearer to extract the Authorization: Bearer <token> header.
jwt.decode(..., SUPABASE_JWT_SECRET, audience="authenticated", algorithms=["HS256"]) verifies the signature and that the token’s "aud" claim matches "authenticated". This example is adapted from a FastAPI guide
dev.to
. If verification fails, we throw a 401 error.
The backend makes no assumptions about sessions; it simply checks the JWT on each request. It does not handle refresh tokens – that is solely the extension’s job.
Part E: Refresh Token Logic
When the access token expires (typically after ~1 hour), the backend will respond with 401. The extension must then catch this and use the stored refresh token to obtain a new access token from Supabase. Sequence of Events:
Extension makes API call with (expired) access token.
Backend returns 401 Unauthorized.
Extension catches the 401 error. It then reads the refresh_token from storage.
Extension sends a POST to Supabase’s token endpoint to refresh:
css
Copy
Edit
POST https://<SUPABASE_URL>/auth/v1/token?grant_type=refresh_token
Headers: {
  "apikey": "<your-anon-key>",
  "Content-Type": "application/json"
}
Body: { "refresh_token": "<stored_refresh_token>" }
This endpoint is documented in Supabase resources
stackoverflow.com
stackoverflow.com
.
Supabase responds with a new JSON containing a fresh access_token (and often a new refresh_token).
Extension updates chrome.storage.local with the new tokens.
Extension retries the original API request using the new access token.
This logic is necessary because Chrome does not auto-refresh tokens obtained via launchWebAuthFlow
xiegerts.com
. For example:
js
Copy
Edit
async function fetchWithAutoRefresh(url, options = {}) {
  // Get the stored access token
  let { access_token, refresh_token } = await chrome.storage.local.get(["access_token", "refresh_token"]);
  if (!access_token) throw new Error("No access token available");

  // Attach token to request
  if (!options.headers) options.headers = {};
  options.headers["Authorization"] = `Bearer ${access_token}`;

  let res = await fetch(url, options);
  if (res.status === 401 && refresh_token) {
    // Access token expired – attempt refresh
    const tokenUrl = `${SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`;
    const refreshRes = await fetch(tokenUrl, {
      method: 'POST',
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ refresh_token })
    });
    if (!refreshRes.ok) throw new Error("Refresh token invalid");

    const data = await refreshRes.json();
    // Save new tokens
    await chrome.storage.local.set({
      access_token: data.access_token,
      refresh_token: data.refresh_token
    });
    // Retry original request with new token
    options.headers["Authorization"] = `Bearer ${data.access_token}`;
    res = await fetch(url, options);
  }
  return res;
}
The above handles catching a 401, calling Supabase’s /token?grant_type=refresh_token endpoint (as shown on StackOverflow
stackoverflow.com
stackoverflow.com
), and retrying. Remember to include your Supabase apikey (the anon key) in the header or as a query parameter. Backend Role: The FastAPI server is not involved in this refresh flow. It simply rejects expired tokens (401). The Chrome extension is solely responsible for catching that, contacting Supabase with the refresh token, storing the new token, and retrying. In other words, after the initial login, all token renewal happens client-side with Supabase directly
xiegerts.com
. Summary: On expiration, the extension uses the refresh token with Supabase’s auth/v1/token endpoint to get a new access_token (and refresh_token)
stackoverflow.com
stackoverflow.com
. It updates its local storage and retries the API call with the fresh access token. Throughout, the backend stays stateless, only verifying whatever token it is given. Sources: The above workflow follows Supabase’s OAuth patterns and Chrome extension OAuth guidelines
github.com
supabase.com
. Key implementation examples are drawn from official docs and community solutions
